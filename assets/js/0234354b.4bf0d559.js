"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6119],{91323:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a Trove object.","params":[],"returns":[{"desc":"","lua_type":"Trove"}],"function_type":"static","source":{"line":57,"path":"modules/trove/init.lua"}},{"name":"Extend","desc":"Creates and adds another trove to itself. This is just shorthand\\nfor `trove:Construct(Trove)`. This is useful for contexts where\\nthe trove object is present, but the class itself isn\'t.\\n\\n:::note\\nThis does _not_ clone the trove. In other words, the objects in the\\ntrove are not given to the new constructed trove. This is simply to\\nconstruct a new Trove and add it as an object to track.\\n:::\\n\\n```lua\\nlocal trove = Trove.new()\\nlocal subTrove = trove:Extend()\\n\\ntrove:Clean() -- Cleans up the subTrove too\\n```","params":[],"returns":[{"desc":"","lua_type":"Trove"}],"function_type":"method","source":{"line":83,"path":"modules/trove/init.lua"}},{"name":"Clone","desc":"Clones the given instance and adds it to the trove. Shorthand for\\n`trove:Add(instance:Clone())`.","params":[{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"Instance\\n"}],"function_type":"method","source":{"line":94,"path":"modules/trove/init.lua"}},{"name":"Construct","desc":"Constructs a new object from either the\\ntable or function given.\\n\\nIf a table is given, the table\'s `new`\\nfunction will be called with the given\\narguments.\\n\\nIf a function is given, the function will\\nbe called with the given arguments.\\n\\nThe result from either of the two options\\nwill be added to the trove.\\n\\nThis is shorthand for `trove:Add(SomeClass.new(...))`\\nand `trove:Add(SomeFunction(...))`.\\n\\n```lua\\nlocal Signal = require(somewhere.Signal)\\n\\n-- All of these are identical:\\nlocal s = trove:Construct(Signal)\\nlocal s = trove:Construct(Signal.new)\\nlocal s = trove:Construct(function() return Signal.new() end)\\nlocal s = trove:Add(Signal.new())\\n\\n-- Even Roblox instances can be created:\\nlocal part = trove:Construct(Instance, \\"Part\\")\\n```","params":[{"name":"class","desc":"","lua_type":"table | (...any) -> any"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"any"}],"function_type":"method","source":{"line":134,"path":"modules/trove/init.lua"}},{"name":"Connect","desc":"Connects the function to the signal, adds the connection\\nto the trove, and then returns the connection.\\n\\nThis is shorthand for `trove:Add(signal:Connect(fn))`.\\n\\n```lua\\ntrove:Connect(workspace.ChildAdded, function(instance)\\n\\tprint(instance.Name .. \\" added to workspace\\")\\nend)\\n```","params":[{"name":"signal","desc":"","lua_type":"RBXScriptSignal"},{"name":"fn","desc":"","lua_type":"(...: any) -> ()"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","source":{"line":163,"path":"modules/trove/init.lua"}},{"name":"BindToRenderStep","desc":"Calls `RunService:BindToRenderStep` and registers a function in the\\ntrove that will call `RunService:UnbindFromRenderStep` on cleanup.\\n\\n```lua\\ntrove:BindToRenderStep(\\"Test\\", Enum.RenderPriority.Last.Value, function(dt)\\n\\t-- Do something\\nend)\\n```","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"priority","desc":"","lua_type":"number"},{"name":"fn","desc":"","lua_type":"(dt: number) -> ()"}],"returns":[],"function_type":"method","source":{"line":183,"path":"modules/trove/init.lua"}},{"name":"AddPromise","desc":"Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise\\nis removed. The exact promise is returned, thus allowing chaining.\\n\\n```lua\\ntrove:AddPromise(doSomethingThatReturnsAPromise())\\n\\t:andThen(function()\\n\\t\\tprint(\\"Done\\")\\n\\tend)\\n-- Will cancel the above promise (assuming it didn\'t resolve immediately)\\ntrove:Clean()\\n\\nlocal p = trove:AddPromise(doSomethingThatReturnsAPromise())\\n-- Will also cancel the promise\\ntrove:Remove(p)\\n```\\n\\n:::caution Promise v4 Only\\nThis is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.\\n:::","params":[{"name":"promise","desc":"","lua_type":"Promise"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"method","source":{"line":216,"path":"modules/trove/init.lua"}},{"name":"Add","desc":"Adds an object to the trove. Once the trove is cleaned or\\ndestroyed, the object will also be cleaned up.\\n\\nThe following types are accepted (e.g. `typeof(object)`):\\n\\n| Type | Cleanup |\\n| ---- | ------- |\\n| `Instance` | `object:Destroy()` |\\n| `RBXScriptConnection` | `object:Disconnect()` |\\n| `function` | `object()` |\\n| `thread` | `coroutine.close(object)` |\\n| `table` | `object:Destroy()` _or_ `object:Disconnect()` |\\n| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |\\n\\nReturns the object added.\\n\\n```lua\\n-- Add a part to the trove, then destroy the trove,\\n-- which will also destroy the part:\\nlocal part = Instance.new(\\"Part\\")\\ntrove:Add(part)\\ntrove:Destroy()\\n\\n-- Add a function to the trove:\\ntrove:Add(function()\\n\\tprint(\\"Cleanup!\\")\\nend)\\ntrove:Destroy()\\n\\n-- Standard cleanup from table:\\nlocal tbl = {}\\nfunction tbl:Destroy()\\n\\tprint(\\"Cleanup\\")\\nend\\ntrove:Add(tbl)\\n\\n-- Custom cleanup from table:\\nlocal tbl = {}\\nfunction tbl:DoSomething()\\n\\tprint(\\"Do something on cleanup\\")\\nend\\ntrove:Add(tbl, \\"DoSomething\\")\\n```","params":[{"name":"object","desc":"Object to track","lua_type":"any"},{"name":"cleanupMethod","desc":"Optional cleanup name override","lua_type":"string?"}],"returns":[{"desc":"","lua_type":"object: any"}],"function_type":"method","source":{"line":281,"path":"modules/trove/init.lua"}},{"name":"Remove","desc":"Removes the object from the Trove and cleans it up.\\n\\n```lua\\nlocal part = Instance.new(\\"Part\\")\\ntrove:Add(part)\\ntrove:Remove(part)\\n```","params":[{"name":"object","desc":"Object to remove","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"method","source":{"line":300,"path":"modules/trove/init.lua"}},{"name":"Clean","desc":"Cleans up all objects in the trove. This is\\nsimilar to calling `Remove` on each object\\nwithin the trove. The ordering of the objects\\nremoved is _not_ guaranteed.","params":[],"returns":[],"function_type":"method","source":{"line":313,"path":"modules/trove/init.lua"}},{"name":"AttachToInstance","desc":"Attaches the trove to a Roblox instance. Once this\\ninstance is removed from the game (parent or ancestor\'s\\nparent set to `nil`), the trove will automatically\\nclean up.\\n\\n:::caution\\nWill throw an error if `instance` is not a descendant\\nof the game hierarchy.\\n:::","params":[{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","source":{"line":364,"path":"modules/trove/init.lua"}},{"name":"Destroy","desc":"Alias for `trove:Clean()`.","params":[],"returns":[],"function_type":"method","source":{"line":378,"path":"modules/trove/init.lua"}}],"properties":[],"types":[],"name":"Trove","desc":"A Trove is helpful for tracking any sort of object during\\nruntime that needs to get cleaned up at some point.","source":{"line":50,"path":"modules/trove/init.lua"}}')}}]);