[{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/RbxUtil/api/ClientRemoteSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection "},{"title":"Types","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal##","content":""},{"title":"​","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal#Connection","content":"interface Connection { Disconnect: () → () }  Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/RbxUtil/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"Comm","type":0,"sectionRef":"#","url":"/RbxUtil/api/Comm","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Comm","url":"/RbxUtil/api/Comm#properties","content":" "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/RbxUtil/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/RbxUtil/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm  "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/RbxUtil/api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/RbxUtil/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object. "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"/RbxUtil/api/ClientComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/RbxUtil/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. "},{"title":"EnumList","type":0,"sectionRef":"#","url":"/RbxUtil/api/EnumList","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#functions","content":" "},{"title":"new​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#new","content":"&lt;/&gt; EnumList.new( name: string, enums: {string} ) → EnumList Constructs a new EnumList. local directions = EnumList.new(&quot;Directions&quot;, { &quot;Up&quot;, &quot;Down&quot;, &quot;Left&quot;, &quot;Right&quot;, }) local direction = directions.Up   "},{"title":"BelongsTo​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#BelongsTo","content":"&lt;/&gt; EnumList:BelongsTo(obj: any) → boolean Returns true if obj belongs to the EnumList.  "},{"title":"GetEnumItems​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#GetEnumItems","content":"since v2.0.0 &lt;/&gt; EnumList:GetEnumItems() → {EnumItem} "},{"title":"Types","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList##","content":""},{"title":"​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#EnumItem","content":"interface EnumItem { Name: string Value: number EnumType: EnumList }  Returns an array of all enum items.  "},{"title":"GetName​","type":1,"pageTitle":"EnumList","url":"/RbxUtil/api/EnumList#GetName","content":"since v2.0.0 &lt;/&gt; EnumList:GetName() → string Get the name of the enum. "},{"title":"Input","type":0,"sectionRef":"#","url":"/RbxUtil/api/Input","content":"On this page Input The Input package provides access to various user input classes. PreferredInput Mouse Keyboard Touch Gamepad Reference the desired input modules via the Input package to get started: local PreferredInput = require(Packages.Input).PreferredInput local Mouse = require(Packages.Input).Mouse local Keyboard = require(Packages.Input).Keyboard local Touch = require(Packages.Input).Touch local Gamepad = require(Packages.Input).Gamepad ","keywords":""},{"title":"Keyboard","type":0,"sectionRef":"#","url":"/RbxUtil/api/Keyboard","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#properties","content":" "},{"title":"KeyDown​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#KeyDown","content":"Event &lt;/&gt; Keyboard.KeyDown: Signal&lt;Enum.KeyCode&gt; Fired when a key is pressed. keyboard.KeyDown:Connect(function(key: KeyCode) print(&quot;Key pressed&quot;, key) end)   "},{"title":"KeyUp​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#KeyUp","content":"Event &lt;/&gt; Keyboard.KeyUp: Signal&lt;Enum.KeyCode&gt; Fired when a key is released. keyboard.KeyUp:Connect(function(key: KeyCode) print(&quot;Key released&quot;, key) end)  "},{"title":"Functions​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#new","content":"&lt;/&gt; Keyboard.new() → Keyboard Constructs a new keyboard input capturer. local keyboard = Keyboard.new()   "},{"title":"IsKeyDown​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#IsKeyDown","content":"&lt;/&gt; Keyboard:IsKeyDown(keyCode: Enum.KeyCode) → boolean Check if the given key is down. local w = keyboard:IsKeyDown(Enum.KeyCode.W) if w then ... end   "},{"title":"AreKeysDown​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#AreKeysDown","content":"&lt;/&gt; Keyboard:AreKeysDown( keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode ) → boolean Check if both keys are down. Useful for key combinations. local shiftA = keyboard:AreKeysDown(Enum.KeyCode.LeftShift, Enum.KeyCode.A) if shiftA then ... end   "},{"title":"AreEitherKeysDown​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#AreEitherKeysDown","content":"&lt;/&gt; Keyboard:AreEitherKeysDown( keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode ) → boolean Check if either of the keys are down. Useful when two keys might perform the same operation. local wOrUp = keyboard:AreEitherKeysDown(Enum.KeyCode.W, Enum.KeyCode.Up) if wOrUp then -- Go forward end   "},{"title":"Destroy​","type":1,"pageTitle":"Keyboard","url":"/RbxUtil/api/Keyboard#Destroy","content":"&lt;/&gt; Keyboard:Destroy() → () Destroy the keyboard input capturer. "},{"title":"Concur","type":0,"sectionRef":"#","url":"/RbxUtil/api/Concur","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#types","content":" "},{"title":"Errors​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#Errors","content":"&lt;/&gt; interface Errors { Stopped: &quot;Stopped&quot; Timeout: &quot;Timeout&quot; }  "},{"title":"Properties​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#properties","content":" "},{"title":"Errors​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#Errors","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Concur.Errors: Errors  "},{"title":"Functions​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#functions","content":" "},{"title":"spawn​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#spawn","content":"&lt;/&gt; Concur.spawn( fn: AnyFn, ...: any ) → Concur Spawns the function using task.spawn. local c = Concur.spawn(function() task.wait(5) return &quot;Hello!&quot; end) c:OnCompleted(function(err, msg) if err then error(err) end print(msg) --&gt; Hello! end))   "},{"title":"defer​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#defer","content":"&lt;/&gt; Concur.defer( fn: AnyFn, ...: any ) → Concur Same as Concur.spawn, but uses task.defer internally.  "},{"title":"delay​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#delay","content":"&lt;/&gt; Concur.delay( delayTime: number, fn: AnyFn, ...: any ) → Concur Same as Concur.spawn, but uses task.delay internally.  "},{"title":"value​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#value","content":"&lt;/&gt; Concur.value(value: any) → Concur Resolves to the given value right away. local val = Concur.value(10) val:OnCompleted(function(v) print(v) --&gt; 10 end)   "},{"title":"event​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#event","content":"&lt;/&gt; Concur.event( event: RBXScriptSignal , predicate: ((...any) → boolean)? ) → () Completes the Concur instance once the event is fired and the predicate function returns true (if no predicate is given, then completes once the event first fires). The Concur instance will return the values given by the event. -- Wait for next player to touch an object: local touch = Concur.event(part.Touched, function(toucher) return Players:GetPlayerFromCharacter(toucher.Parent) ~= nil end) touch:OnCompleted(function(err, toucher) print(toucher) end)   "},{"title":"all​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#all","content":"&lt;/&gt; Concur.all(concurs: {Concur}) → Concur Completes once all Concur instances have been completed. All values will be available in a packed table in the same order they were passed. local c1 = Concur.spawn(function() return 10 end) local c2 = Concur.delay(0.5, function() return 15 end) local c3 = Concur.value(20) local c4 = Concur.spawn(function() error(&quot;failed&quot;) end) Concur.all({c1, c2, c3}):OnCompleted(function(err, values) print(values) --&gt; {{nil, 10}, {nil, 15}, {nil, 20}, {&quot;failed&quot;, nil}} end)   "},{"title":"first​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#first","content":"&lt;/&gt; Concur.first(concurs: {Concur}) → Concur Completes once the first Concur instance is completed without an error. All other Concur instances are then stopped. local c1 = Concur.delay(1, function() return 10 end) local c2 = Concur.delay(0.5, function() return 5 end) Concur.first({c1, c2}):OnCompleted(function(err, num) print(num) --&gt; 5 end)   "},{"title":"Stop​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#Stop","content":"&lt;/&gt; Concur:Stop() → () Stops the Concur instance. The underlying thread will be cancelled usingtask.cancel. Any bound OnCompleted functions or threads waiting with Await will be completed with the error Concur.Errors.Stopped. local c = Concur.spawn(function() for i = 1,10 do print(i) task.wait(1) end end) task.wait(2.5) c:Stop() -- At this point, will have only printed 1 and 2   "},{"title":"IsCompleted​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#IsCompleted","content":"&lt;/&gt; Concur:IsCompleted() → boolean Check if the Concur instance is finished.  "},{"title":"Await​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#Await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Concur:Await(timeout: number?) → ( Error, ...any? ) Yields the calling thread until the Concur instance is completed: local c = Concur.delay(5, function() return &quot;Hi&quot; end) local err, msg = c:Await() print(msg) --&gt; Hi The Await method can be called after the Concur instance has been completed too, in which case the completed values will be returned immediately without yielding the thread: local c = Concur.spawn(function() return 10 end) task.wait(5) -- Called after 'c' has been completed, but still captures the value: local err, num = c:Await() print(num) --&gt; 10 It is always good practice to make sure that the err value is handled by checking if it is not nil: local c = Concur.spawn(function() error(&quot;failed&quot;) end) local err, value = c:Await() if err ~= nil then print(err) --&gt; failed -- Handle error `err` else -- Handle `value` end This will stop awaiting if the Concur instance was stopped too, in which case the err will be equal to Concur.Errors.Stopped: local c = Concur.delay(10, function() end) c:Stop() local err = c:Await() if err == Concur.Errors.Stopped then print(&quot;Was stopped&quot;) end An optional timeout can be given, which will return theConcur.Errors.Timeout error if timed out. Timing out does not stop the Concur instance, so other callers to Await or OnCompleted can still grab the resulting values. local c = Concur.delay(10, function() end) local err = c:Await(1) if err == Concur.Errors.Timeout then -- Handle timeout end   "},{"title":"OnCompleted​","type":1,"pageTitle":"Concur","url":"/RbxUtil/api/Concur#OnCompleted","content":"&lt;/&gt; Concur:OnCompleted( fn: ( Error, ...any? ) → (), timeout: number? ) → () → () Calls the given function once the Concur instance is completed: local c = Concur.delay(5, function() return &quot;Hi&quot; end) c:OnCompleted(function(err, msg) print(msg) --&gt; Hi end) A function is returned that can be used to unbind the function to no longer fire when the Concur instance is completed: local c = Concur.delay(5, function() end) local unbind = c:OnCompleted(function() print(&quot;Completed&quot;) end) unbind() -- Never prints &quot;Completed&quot; The OnCompleted method can be called after the Concur instance has been completed too, in which case the given function will be called immediately with the completed values: local c = Concur.spawn(function() return 10 end) task.wait(5) -- Called after 'c' has been completed, but still captures the value: c:OnCompleted(function(err, num) print(num) --&gt; 10 end) It is always good practice to make sure that the err value is handled by checking if it is not nil: local c = Concur.spawn(function() error(&quot;failed&quot;) end) c:OnCompleted(function(err, value) if err ~= nil then print(err) --&gt; failed -- Handle error `err` return end -- Handle `value` end) This will call the function if the Concur instance was stopped too, in which case the err will be equal to Concur.Errors.Stopped: local c = Concur.delay(10, function() end) c:OnCompleted(function(err) if err == Concur.Errors.Stopped then print(&quot;Was stopped&quot;) end end) c:Stop() An optional timeout can also be supplied, which will call the function with the Concur.Errors.Timeout error: local c = Concur.delay(10, function() end) c:OnCompleted(function(err) if err == Concur.Errors.Timeout then -- Handle timeout end end, 1)  "},{"title":"Loader","type":0,"sectionRef":"#","url":"/RbxUtil/api/Loader","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#types","content":" "},{"title":"PredicateFn​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#PredicateFn","content":"&lt;/&gt; type PredicateFn = (module: ModuleScript ) → boolean Predicate function type. "},{"title":"Functions​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#functions","content":" "},{"title":"LoadChildren​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#LoadChildren","content":"&lt;/&gt; Loader.LoadChildren( parent: Instance , predicate: PredicateFn? ) → {[string]: any} Requires all children ModuleScripts. If a predicate function is provided, then the module will only be loaded if the predicate returns true for the the given ModuleScript. -- Load all ModuleScripts directly under MyModules: Loader.LoadChildren(ReplicatedStorage.MyModules) -- Load all ModuleScripts directly under MyModules if they have names ending in 'Service': Loader.LoadChildren(ReplicatedStorage.MyModules, function(moduleScript) return moduleScript.Name:match(&quot;Service$&quot;) ~= nil end)   "},{"title":"LoadDescendants​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#LoadDescendants","content":"&lt;/&gt; Loader.LoadDescendants( parent: Instance , predicate: PredicateFn? ) → {[string]: any} Requires all descendant ModuleScripts. If a predicate function is provided, then the module will only be loaded if the predicate returns true for the the given ModuleScript. -- Load all ModuleScripts under MyModules: Loader.LoadDescendants(ReplicatedStorage.MyModules) -- Load all ModuleScripts under MyModules if they have names ending in 'Service': Loader.LoadDescendants(ReplicatedStorage.MyModules, function(moduleScript) return moduleScript.Name:match(&quot;Service$&quot;) ~= nil end)   "},{"title":"MatchesName​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#MatchesName","content":"&lt;/&gt; Loader.MatchesName(matchName: string) → (module: ModuleScript ) → boolean A commonly-used predicate in the LoadChildren and LoadDescendants functions is one to match names. Therefore, the MatchesName utility function provides a quick way to create such predicates. Loader.LoadDescendants(ReplicatedStorage.MyModules, Loader.MatchesName(&quot;Service$&quot;))   "},{"title":"SpawnAll​","type":1,"pageTitle":"Loader","url":"/RbxUtil/api/Loader#SpawnAll","content":"&lt;/&gt; Loader.SpawnAll( loadedModules: {[string]: any}, methodName: string ) → () Utility function for spawning a specific method in all given modules. If a module does not contain the specified method, it is simply skipped. Methods are called with task.spawn internally. For example, if the modules are expected to have an OnStart() method, then SpawnAll() could be used to start all of them directly after they have been loaded: local MyModules = ReplicatedStorage.MyModules -- Load all modules under MyModules and then call their OnStart methods: Loader.SpawnAll(Loader.LoadDescendants(MyModules), &quot;OnStart&quot;) -- Same as above, but only loads modules with names that end with Service: Loader.SpawnAll( Loader.LoadDescendants(MyModules, Loader.MatchesName(&quot;Service$&quot;)), &quot;OnStart&quot; )  "},{"title":"Component","type":0,"sectionRef":"#","url":"/RbxUtil/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/RbxUtil/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end  "},{"title":"Gamepad","type":0,"sectionRef":"#","url":"/RbxUtil/api/Gamepad","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#types","content":" "},{"title":"GamepadState​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#GamepadState","content":"&lt;/&gt; type GamepadState = {[Enum.KeyCode]: InputObject }  "},{"title":"Properties​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#properties","content":" "},{"title":"ButtonDown​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#ButtonDown","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.ButtonDown: Signal&lt;( button: Enum.KeyCode, processed: boolean )&gt; The ButtonDown signal fires when a gamepad button is pressed down. The pressed KeyCode is passed to the signal, along with whether or not the event was processed. gamepad.ButtonDown:Connect(function(button: Enum.KeyCode, processed: boolean) print(&quot;Button down&quot;, button, processed) end)   "},{"title":"ButtonUp​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#ButtonUp","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.ButtonUp: Signal&lt;( button: Enum.KeyCode, processed: boolean )&gt; The ButtonUp signal fires when a gamepad button is released. The released KeyCode is passed to the signal, along with whether or not the event was processed. gamepad.ButtonUp:Connect(function(button: Enum.KeyCode, processed: boolean) print(&quot;Button up&quot;, button, processed) end)   "},{"title":"Connected​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#Connected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.Connected: Signal Fires when the gamepad is connected. This will not fire if the active gamepad is switched. To detect switching to different active gamepads, use the GamepadChanged signal. There is also a gamepad:IsConnected() method. gamepad.Connected:Connect(function() print(&quot;Connected&quot;) end)   "},{"title":"Disconnected​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#Disconnected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.Disconnected: Signal Fires when the gamepad is disconnected. This will not fire if the active gamepad is switched. To detect switching to different active gamepads, use the GamepadChanged signal. There is also a gamepad:IsConnected() method. gamepad.Disconnected:Connect(function() print(&quot;Disconnected&quot;) end)   "},{"title":"GamepadChanged​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#GamepadChanged","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.GamepadChanged: Signal&lt;gamepad: Enum.UserInputType&gt; Fires when the active gamepad switches. Internally, the gamepad object will always wrap around the active gamepad, so nothing needs to be changed. gamepad.GamepadChanged:Connect(function(newGamepad: Enum.UserInputType) print(&quot;Active gamepad changed to:&quot;, newGamepad) end)   "},{"title":"DefaultDeadzone​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#DefaultDeadzone","content":"&lt;/&gt; Gamepad.DefaultDeadzone: number  Default Defaults to 0.05 The default deadzone used for trigger and thumbstick analog readings. It is usually best to set this to a small value, or allow players to set this option themselves in an in-game settings menu. The GetThumbstick and GetTrigger methods also allow a deadzone value to be passed in, which overrides this value.  "},{"title":"SupportsVibration​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#SupportsVibration","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.SupportsVibration: boolean Flag to indicate if the currently-active gamepad supports haptic motor vibration. It is safe to use the motor methods on the gamepad without checking this value, but nothing will happen if the motors are not supported.  "},{"title":"State​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#State","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Gamepad.State: GamepadState Maps KeyCodes to the matching InputObjects within the gamepad. These can be used to directly read the current input state of a given part of the gamepad. For most cases, the given methods and properties of Gamepad should make use of this table quite rare, but it is provided for special use-cases that might occur. Do Not Cache These state objects will change if the active gamepad changes. Because a player might switch up gamepads during playtime, it cannot be assumed that these state objects will always be the same. Thus they should be accessed directly from this State table anytime they need to be used. local leftThumbstick = gamepad.State[Enum.KeyCode.Thumbstick1] print(leftThumbstick.Position) -- It would be better to use gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1), -- but this is just an example of direct state access.  "},{"title":"Functions​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#new","content":"&lt;/&gt; Gamepad.new(gamepad: Enum.UserInputType?) → Gamepad Constructs a gamepad object. If no gamepad UserInputType is provided, this object will always wrap around the currently-active gamepad, even if it changes. In most cases where input is needed from just the primary gamepad used by the player, leaving the gamepad argument blank is preferred. Only include the gamepad argument when it is necessary to hard-lock the object to a specific gamepad input type. -- In most cases, construct the gamepad as such: local gamepad = Gamepad.new() -- If the exact UserInputType gamepad is needed, pass it as such: local gamepad = Gamepad.new(Enum.UserInputType.Gamepad1)   "},{"title":"GetThumbstick​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#GetThumbstick","content":"&lt;/&gt; Gamepad:GetThumbstick( thumbstick: Enum.KeyCode, deadzoneThreshold: number? ) → Vector2  Gets the position of the given thumbstick. The two thumbstick KeyCodes are Enum.KeyCode.Thumbstick1 and Enum.KeyCode.Thumbstick2. If deadzoneThreshold is not included, the DefaultDeadzone value is used instead. local leftThumbstick = gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1) print(&quot;Left thumbstick position&quot;, leftThumbstick)   "},{"title":"GetTrigger​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#GetTrigger","content":"&lt;/&gt; Gamepad:GetTrigger( trigger: KeyCode , deadzoneThreshold: number? ) → number Gets the position of the given trigger. The triggers are usually going to be Enum.KeyCode.ButtonL2 and Enum.KeyCode.ButtonR2. These trigger buttons are analog, and will output a value between the range of [0, 1]. If deadzoneThreshold is not included, the DefaultDeadzone value is used instead. local triggerAmount = gamepad:GetTrigger(Enum.KeyCode.ButtonR2) print(triggerAmount)   "},{"title":"IsButtonDown​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#IsButtonDown","content":"&lt;/&gt; Gamepad:IsButtonDown(gamepadButton: KeyCode ) → boolean Returns true if the given button is down. This includes any button on the gamepad, such as Enum.KeyCode.ButtonA, Enum.KeyCode.ButtonL3, Enum.KeyCode.DPadUp, etc. -- Check if the 'A' button is down: if gamepad:IsButtonDown(Enum.KeyCode.ButtonA) then print(&quot;ButtonA is down&quot;) end   "},{"title":"IsMotorSupported​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#IsMotorSupported","content":"&lt;/&gt; Gamepad:IsMotorSupported(motor: Enum.VibrationMotor) → boolean Returns true if the given motor is supported. -- Pulse the trigger (e.g. shooting a weapon), but fall back to -- the large motor if not supported: local motor = Enum.VibrationMotor.Large if gamepad:IsMotorSupported(Enum.VibrationMotor.RightTrigger) then motor = Enum.VibrationMotor.RightTrigger end gamepad:PulseMotor(motor, 1, 0.1)   "},{"title":"SetMotor​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#SetMotor","content":"&lt;/&gt; Gamepad:SetMotor( motor: Enum.VibrationMotor, intensity: number ) → number Sets the gamepad's haptic motor to a certain intensity. The intensity value is a number in the range of [0, 1]. gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5)   "},{"title":"PulseMotor​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#PulseMotor","content":"&lt;/&gt; Gamepad:PulseMotor( motor: Enum.VibrationMotor, intensity: number, duration: number ) → () Sets the gamepad's haptic motor to a certain intensity for a given period of time. The motor will stop vibrating after the givenduration has elapsed. Calling any motor setter methods (e.g. SetMotor, PulseMotor, StopMotor) after calling this method will override the pulse. For instance, if PulseMotor is called, and then SetMotor is called right afterwards, SetMotor will take precedent. -- Pulse the large motor for 0.2 seconds with an intensity of 90%: gamepad:PulseMotor(Enum.VibrationMotor.Large, 0.9, 0.2) -- Example of PulseMotor being overridden: gamepad:PulseMotor(Enum.VibrationMotor.Large, 1, 3) task.wait(0.1) gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5) -- Now the pulse won't shut off the motor after 3 seconds, -- because SetMotor was called, which cancels the pulse.   "},{"title":"StopMotor​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#StopMotor","content":"&lt;/&gt; Gamepad:StopMotor(motor: Enum.VibrationMotor) → () Stops the given motor. This is equivalent to callinggamepad:SetMotor(motor, 0). gamepad:SetMotor(Enum.VibrationMotor.Large, 1) task.wait(0.1) gamepad:StopMotor(Enum.VibrationMotor.Large)   "},{"title":"StopMotors​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#StopMotors","content":"&lt;/&gt; Gamepad:StopMotors() → () Stops all motors on the gamepad. gamepad:SetMotor(Enum.VibrationMotor.Large, 1) gamepad:SetMotor(Enum.VibrationMotor.Small, 1) task.wait(0.1) gamepad:StopMotors()   "},{"title":"IsConnected​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#IsConnected","content":"&lt;/&gt; Gamepad:IsConnected() → boolean Returns true if the gamepad is currently connected.  "},{"title":"GetUserInputType​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#GetUserInputType","content":"&lt;/&gt; Gamepad:GetUserInputType() → Enum.UserInputType? Gets the current gamepad UserInputType that the gamepad object is using. This will be nil if there is no connected gamepad.  "},{"title":"SetAutoSelectGui​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#SetAutoSelectGui","content":"&lt;/&gt; Gamepad:SetAutoSelectGui(enabled: boolean) → () Sets the GuiService.AutoSelectGuiEnabled property. This sets whether or not the Select button on a gamepad will try to auto-select a GUI object on screen. This does not turn on/off GUI gamepad navigation, but just the initial selection using the Select button. For UX purposes, it usually is preferred to set this to false and then manually set the GuiService.SelectedObject property within code to set the selected object for gamepads. gamepad:SetAutoSelectGui(false) game:GetService(&quot;GuiService&quot;).SelectedObject = someGuiObject   "},{"title":"IsAutoSelectGuiEnabled​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#IsAutoSelectGuiEnabled","content":"&lt;/&gt; Gamepad:IsAutoSelectGuiEnabled() → boolean Returns the GuiService.AutoSelectGuiEnabled property.  "},{"title":"Destroy​","type":1,"pageTitle":"Gamepad","url":"/RbxUtil/api/Gamepad#Destroy","content":"&lt;/&gt; Gamepad:Destroy() → () Destroys the gamepad object. "},{"title":"Net","type":0,"sectionRef":"#","url":"/RbxUtil/api/Net","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#functions","content":" "},{"title":"RemoteEvent​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#RemoteEvent","content":"&lt;/&gt; Net:RemoteEvent(name: string) → RemoteEvent  Gets a RemoteEvent with the given name. On the server, if the RemoteEvent does not exist, then it will be created with the given name. On the client, if the RemoteEvent does not exist, then it will wait until it exists for at least 10 seconds. If the RemoteEvent does not exist after 10 seconds, an error will be thrown. local remoteEvent = Net:RemoteEvent(&quot;PointsChanged&quot;)   "},{"title":"Connect​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#Connect","content":"&lt;/&gt; Net:Connect( name: string, handler: (...any) → () ) → RBXScriptConnection  Connects a handler function to the given RemoteEvent. -- Client Net:Connect(&quot;PointsChanged&quot;, function(points) print(&quot;Points&quot;, points) end) -- Server Net:Connect(&quot;SomeEvent&quot;, function(player, ...) end)   "},{"title":"RemoteFunction​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#RemoteFunction","content":"&lt;/&gt; Net:RemoteFunction(name: string) → RemoteFunction  Gets a RemoteFunction with the given name. On the server, if the RemoteFunction does not exist, then it will be created with the given name. On the client, if the RemoteFunction does not exist, then it will wait until it exists for at least 10 seconds. If the RemoteFunction does not exist after 10 seconds, an error will be thrown. local remoteFunction = Net:RemoteFunction(&quot;GetPoints&quot;)   "},{"title":"Handle​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#Handle","content":"This item only works when running on the server. Server &lt;/&gt; Net:Handle( name: string, handler: ( player: Player , ...any ) → ...any ) → () Sets the invocation function for the given RemoteFunction. Net:Handle(&quot;GetPoints&quot;, function(player) return 10 end)   "},{"title":"Invoke​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#Invoke","content":"This item only works when running on the client. Client &lt;/&gt; Net:Invoke( name: string, ...: any ) → ...any Invokes the RemoteFunction with the given arguments. local points = Net:Invoke(&quot;GetPoints&quot;)   "},{"title":"Clean​","type":1,"pageTitle":"Net","url":"/RbxUtil/api/Net#Clean","content":"This item only works when running on the server. Server &lt;/&gt; Net:Clean() → () Destroys all RemoteEvents and RemoteFunctions. This should really only be used in testing environments and not during runtime. "},{"title":"Log","type":0,"sectionRef":"#","url":"/RbxUtil/api/Log","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#types","content":" "},{"title":"LogItem​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#LogItem","content":"&lt;/&gt; interface LogItem { Log: ( message: any, customData: table? )-- Log the message Every: (n: number)-- Log only every n times AtMostEvery: ( n: number, timeUnit: TimeUnit )-- Log only every n TimeUnit Throw: ()-- Throw an error Wrap: ()-- Returns a function that can be called which will log out the given arguments Assert: ( condition: boolean, args: ... )-- Assert the condition }   "},{"title":"TimeUnit​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#TimeUnit","content":"&lt;/&gt; interface TimeUnit { Milliseconds: number Seeconds: number Minutes: number Hours: number Days: number Weeks: number Months: number Years: number }  "},{"title":"Properties​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#properties","content":" "},{"title":"TimeUnit​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#TimeUnit","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Log.TimeUnit: TimeUnit   "},{"title":"Level​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#Level","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Log.Level: Level  "},{"title":"Functions​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#new","content":"&lt;/&gt; Log.new() → Log Construct a new Log object. warning This should only be called once per script.  "},{"title":"At​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#At","content":"&lt;/&gt; Log:At(level: LogLevel) → LogItem "},{"title":"Types","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log##","content":""},{"title":"​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#Level","content":"interface Level { Trace: number Debug: number Info: number Warning: number Error: number Fatal: number }    "},{"title":"AtTrace​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtTrace","content":"&lt;/&gt; Log:AtTrace() → LogItem Get a LogItem at the Trace log level.  "},{"title":"AtDebug​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtDebug","content":"&lt;/&gt; Log:AtDebug() → LogItem Get a LogItem at the Debug log level.  "},{"title":"AtInfo​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtInfo","content":"&lt;/&gt; Log:AtInfo() → LogItem Get a LogItem at the Info log level.  "},{"title":"AtWarning​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtWarning","content":"&lt;/&gt; Log:AtWarning() → LogItem Get a LogItem at the Warning log level.  "},{"title":"AtError​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtError","content":"&lt;/&gt; Log:AtError() → LogItem Get a LogItem at the Error log level.  "},{"title":"AtFatal​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#AtFatal","content":"&lt;/&gt; Log:AtFatal() → LogItem Get a LogItem at the Fatal log level.  "},{"title":"Assert​","type":1,"pageTitle":"Log","url":"/RbxUtil/api/Log#Assert","content":"&lt;/&gt; Log:Assert( condition: boolean, ...: any ) → () Asserts the condition and then logs the following arguments at the Error level if the condition fails. "},{"title":"Mouse","type":0,"sectionRef":"#","url":"/RbxUtil/api/Mouse","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#properties","content":" "},{"title":"LeftDown​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#LeftDown","content":"Event &lt;/&gt; Mouse.LeftDown: Signal   "},{"title":"LeftUp​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#LeftUp","content":"Event &lt;/&gt; Mouse.LeftUp: Signal   "},{"title":"RightDown​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#RightDown","content":"Event &lt;/&gt; Mouse.RightDown: Signal   "},{"title":"RightUp​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#RightUp","content":"Event &lt;/&gt; Mouse.RightUp: Signal   "},{"title":"Moved​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Moved","content":"Event &lt;/&gt; Mouse.Moved: Signal&lt;Vector2 &gt; mouse.Moved:Connect(function(position) ... end)   "},{"title":"Scrolled​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Scrolled","content":"Event &lt;/&gt; Mouse.Scrolled: Signal&lt;number&gt; mouse.Scrolled:Connect(function(scrollAmount) ... end)  "},{"title":"Functions​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#new","content":"&lt;/&gt; Mouse.new() → Mouse Constructs a new mouse input capturer. local mouse = Mouse.new()   "},{"title":"IsLeftDown​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#IsLeftDown","content":"&lt;/&gt; Mouse:IsLeftDown() → boolean Checks if the left mouse button is down.  "},{"title":"IsRightDown​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#IsRightDown","content":"&lt;/&gt; Mouse:IsRightDown() → boolean Checks if the right mouse button is down.  "},{"title":"GetPosition​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#GetPosition","content":"&lt;/&gt; Mouse:GetPosition() → Vector2  Gets the screen position of the mouse.  "},{"title":"GetDelta​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#GetDelta","content":"&lt;/&gt; Mouse:GetDelta() → Vector2  Gets the delta screen position of the mouse. In other words, the distance the mouse has traveled away from its locked position in a given frame (see note about mouse locking below). Only When Mouse Locked Getting the mouse delta is only intended for when the mouse is locked. If the mouse is not locked, this will return a zero Vector2. The mouse can be locked using the mouse:Lock() and mouse:LockCenter() method.  "},{"title":"GetRay​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#GetRay","content":"&lt;/&gt; Mouse:GetRay(overridePos: Vector2? ) → Ray  Returns the viewport point ray for the mouse at the current mouse position (or the override position if provided).  "},{"title":"Raycast​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Raycast","content":"&lt;/&gt; Mouse:Raycast( raycastParams: RaycastParams, distance: number?, overridePos: Vector2? ) → RaycastResult? Performs a raycast operation out from the mouse position (or theoverridePos if provided) into world space. The ray will go distance studs forward (or 1000 studs if not provided). Returns the RaycastResult if something was hit, else returns nil. Use Raycast if it is important to capture any objects that could be hit along the projected ray. If objects can be ignored and only the final position of the ray is needed, use Project instead. local params = RaycastParams.new() local result = mouse:Raycast(params) if result then print(result.Instance) else print(&quot;Mouse raycast did not hit anything&quot;) end   "},{"title":"Project​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Project","content":"&lt;/&gt; Mouse:Project( distance: number?, overridePos: Vector2? ) → Vector3  Gets the 3D world position of the mouse when projected forward. This would be the end-position of a raycast if nothing was hit. Similar to Raycast, optional distance and overridePos arguments are allowed. Use Project if you want to get the 3D world position of the mouse at a given distance but don't care about any objects that could be in the way. It is much faster to project a position into 3D space than to do a full raycast operation. local params = RaycastParams.new() local distance = 200 local result = mouse:Raycast(params, distance) if result then -- Do something with result else -- Raycast failed, but still get the world position of the mouse: local worldPosition = mouse:Project(distance) end   "},{"title":"Lock​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Lock","content":"&lt;/&gt; Mouse:Lock() → () Locks the mouse in its current position on screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock Be sure to explicitly call mouse:Unlock() before cleaning up the mouse. The Destroy method does not unlock the mouse since there is no way to guarantee who &quot;owns&quot; the mouse lock.  "},{"title":"LockCenter​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#LockCenter","content":"&lt;/&gt; Mouse:LockCenter() → () Locks the mouse in the center of the screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock See cautionary in Lock method above.  "},{"title":"Unlock​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Unlock","content":"&lt;/&gt; Mouse:Unlock() → () Unlocks the mouse.  "},{"title":"Destroy​","type":1,"pageTitle":"Mouse","url":"/RbxUtil/api/Mouse#Destroy","content":"&lt;/&gt; Mouse:Destroy() → () Destroys the mouse. "},{"title":"PID","type":0,"sectionRef":"#","url":"/RbxUtil/api/PID","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#properties","content":" "},{"title":"POnE​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#POnE","content":"&lt;/&gt; PID.POnE: boolean POnE stands for &quot;Proportional on Error&quot;. Set to true by default. true: The PID applies the proportional calculation on the error. false: The PID applies the proportional calculation on the measurement. Setting this value to false may help the PID move smoother and help eliminate overshoot. local pid = PID.new(...) pid.POnE = true|false  "},{"title":"Functions​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#new","content":"&lt;/&gt; PID.new( min: number,-- Minimum value the PID can output max: number,-- Maximum value the PID can output kp: number,-- Proportional coefficient ki: number,-- Integral coefficient kd: number-- Derivative coefficient ) → PID Constructs a new PID. local pid = PID.new(0, 1, 0.1, 0, 0)   "},{"title":"Reset​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#Reset","content":"&lt;/&gt; PID:Reset() → () Resets the PID to a zero start state.  "},{"title":"Calculate​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#Calculate","content":"&lt;/&gt; PID:Calculate( setpoint: number,-- The desired point to reach input: number-- The current inputted value ) → output: number Calculates the new output based on the setpoint and input. For example, if the PID was being used for a car's throttle control where the throttle can be in the range of [0, 1], then the PID calculation might look like the following: local cruisePID = PID.new(0, 1, ...) local desiredSpeed = 50 RunService.Heartbeat:Connect(function() local throttle = cruisePID:Calculate(desiredSpeed, car.CurrentSpeed) car:SetThrottle(throttle) end)   "},{"title":"Debug​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#Debug","content":"&lt;/&gt; PID:Debug( name: string,-- Folder name parent: Instance? -- Folder parent ) → () Creates a folder that contains attributes that can be used to tune the PID during runtime within the explorer. Studio Only This will only create the folder in Studio. In a real game server, this function will do nothing.  "},{"title":"Destroy​","type":1,"pageTitle":"PID","url":"/RbxUtil/api/PID#Destroy","content":"&lt;/&gt; PID:Destroy() → () Destroys the PID. This is only necessary if calling PID:Debug. "},{"title":"PreferredInput","type":0,"sectionRef":"#","url":"/RbxUtil/api/PreferredInput","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#types","content":" "},{"title":"InputType​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#InputType","content":"&lt;/&gt; type InputType = &quot;MouseKeyboard&quot; | &quot;Touch&quot; | &quot;Gamepad&quot; The InputType is just a string that is either &quot;MouseKeyboard&quot;, &quot;Touch&quot;, or &quot;Gamepad&quot;. "},{"title":"Properties​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#properties","content":" "},{"title":"Current​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#Current","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; PreferredInput.Current: InputType The current preferred InputType. print(PreferredInput.Current)  "},{"title":"Functions​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#functions","content":" "},{"title":"Observe​","type":1,"pageTitle":"PreferredInput","url":"/RbxUtil/api/PreferredInput#Observe","content":"&lt;/&gt; PreferredInput.Observe(handler: (preferred: InputType) → ()) → () → () Observes the preferred input. In other words, the handler function will be fired immediately, as well as any time the preferred input changes. The returned function can be called to disconnect the observer. local disconnect = PreferredInput.Observe(function(preferred) -- Fires immediately &amp; any time the preferred input changes print(preferred) end) -- If/when desired, observer can be stopped by calling the returned function: disconnect()  "},{"title":"Quaternion","type":0,"sectionRef":"#","url":"/RbxUtil/api/Quaternion","content":"","keywords":""},{"title":"Option","type":0,"sectionRef":"#","url":"/RbxUtil/api/Option","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#properties","content":" "},{"title":"None​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#functions","content":" "},{"title":"Some​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"Is​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Assert​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Serialize​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Match​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Match","content":"&lt;/&gt; Option:Match(matches: { Some: (value: any) → any, None: () → any }) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"IsSome​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"IsNone​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"Expect​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Unwrap​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"And​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Or​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"XOr​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value.  "},{"title":"Filter​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"Contains​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#Contains","content":"&lt;/&gt; Option:Contains(value: any) → boolean Returns true if this option contains value.  "},{"title":"__tostring​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"__eq​","type":1,"pageTitle":"Option","url":"/RbxUtil/api/Option#__eq","content":"&lt;/&gt; Option:__eq(opt: Option) → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true  "},{"title":"Types​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#types","content":" "},{"title":"Quaternion​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Quaternion","content":"&lt;/&gt; interface Quaternion { X: number Y: number Z: number W: number } Similar to Vector3s, Quaternions are immutable. You cannot manually set the individual properties of a Quaternion. Instead, a new Quaternion must first be constructed. "},{"title":"Properties​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#properties","content":" "},{"title":"identity​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#identity","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Quaternion.identity: Quaternion Identity Quaternion. Equal to Quaternion.new(0, 0, 0, 1). "},{"title":"Functions​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#new","content":"&lt;/&gt; Quaternion.new( x: number, y: number, z: number, w: number ) → Quaternion Constructs a Quaternion. caution The new constructor assumes the given arguments represent a proper Quaternion. This constructor should only be used if you really know what you're doing.  "},{"title":"euler​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#euler","content":"&lt;/&gt; Quaternion.euler( x: number, y: number, z: number ) → Quaternion Constructs a Quaternion from Euler angles (radians). -- Quaternion rotated 45 degrees on the Y axis: local quat = Quaternion.euler(0, math.rad(45), 0)   "},{"title":"axisAngle​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#axisAngle","content":"&lt;/&gt; Quaternion.axisAngle( axis: Vector3 , angle: number ) → Quaternion Constructs a Quaternion representing a rotation of angle radians around axis. -- Quaternion rotated 45 degrees on the Y axis: local quat = Quaternion.axisAngle(Vector3.yAxis, math.rad(45))   "},{"title":"lookRotation​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#lookRotation","content":"&lt;/&gt; Quaternion.lookRotation( forward: Vector3 , upwards: Vector3? ) → Quaternion Constructs a Quaternion representing a rotation facing forward direction, where upwards represents the upwards direction (this defaults to Vector3.yAxis). -- Create a quaternion facing the same direction as the camera: local camCf = workspace.CurrentCamera.CFrame local quat = Quaternion.lookRotation(camCf.LookVector, camCf.UpVector)   "},{"title":"cframe​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#cframe","content":"&lt;/&gt; Quaternion.cframe(cframe: CFrame ) → Quaternion Constructs a Quaternion from the rotation components of the given cframe. This method ortho-normalizes the CFrame value, so there is no need to do this yourself before calling the function. -- Create a Quaternion representing the rotational CFrame of a part: local quat = Quaternion.cframe(somePart.CFrame)   "},{"title":"__mul​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#__mul","content":"&lt;/&gt; Quaternion.__mul( self: Quaternion, other: Quaternion | Vector3 ) → Quaternion | Vector3  Multiplication metamethod. A Quaternion can be multiplied with another Quaternion or a Vector3. local quat = quatA * quatB local vec = quatA * vecA   "},{"title":"Dot​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Dot","content":"&lt;/&gt; Quaternion:Dot(other: Quaternion) → number Calculates the dot product between the two Quaternions. local dot = quatA:Dot(quatB)   "},{"title":"Slerp​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Slerp","content":"&lt;/&gt; Quaternion:Slerp( other: Quaternion, t: number ) → Quaternion Calculates a spherical interpolation between the two Quaternions. Parameter t represents the percentage between the two rotations, from a range of [0, 1]. Spherical interpolation is great for smoothing or animating between quaternions. local midWay = quatA:Slerp(quatB, 0.5)   "},{"title":"Angle​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Angle","content":"&lt;/&gt; Quaternion:Angle(other: Quaternion) → number Calculates the angle (radians) between the two Quaternions. local angle = quatA:Angle(quatB)   "},{"title":"RotateTowards​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#RotateTowards","content":"&lt;/&gt; Quaternion:RotateTowards( other: Quaternion, maxRadiansDelta: number ) → Quaternion Constructs a new Quaternion that rotates from this Quaternion to the other quaternion, with a maximum rotation of maxRadiansDelta. Internally, this calls Slerp, but limits the movement to maxRadiansDelta. -- Rotate from quatA to quatB, but only by 10 degrees: local q = quatA:RotateTowards(quatB, math.rad(10))   "},{"title":"ToCFrame​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#ToCFrame","content":"&lt;/&gt; Quaternion:ToCFrame(position: Vector3? ) → CFrame  Constructs a CFrame value representing the Quaternion. An optional position Vector can be given to represent the position of the CFrame in 3D space. This defaults to Vector3.zero. -- Construct a CFrame from the quaternion, where the position will be at the origin point: local cf = quat:ToCFrame() -- Construct a CFrame with a given position: local cf = quat:ToCFrame(someVector3) -- e.g., set a part's CFrame: local part = workspace.Part local quat = Quaternion.axisAngle(Vector3.yAxis, math.rad(45)) local cframe = quat:ToCFrame(part.Position) -- Construct CFrame with a positional component part.CFrame = cframe   "},{"title":"ToEulerAngles​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#ToEulerAngles","content":"&lt;/&gt; Quaternion:ToEulerAngles() → Vector3  Calculates the Euler angles (radians) that represent the Quaternion. local euler = quat:ToEulerAngles() print(euler.X, euler.Y, euler.Z)   "},{"title":"ToAxisAngle​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#ToAxisAngle","content":"&lt;/&gt; Quaternion:ToAxisAngle() → ( Vector3 , number ) Calculates the axis and angle representing the Quaternion. local axis, angle = quat:ToAxisAngle()   "},{"title":"Inverse​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Inverse","content":"&lt;/&gt; Quaternion:Inverse() → Quaternion Returns the inverse of the Quaternion. local quatInverse = quat:Inverse()   "},{"title":"Conjugate​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Conjugate","content":"&lt;/&gt; Quaternion:Conjugate() → Quaternion Returns the conjugate of the Quaternion. This is equal to Quaternion.new(-X, -Y, -Z, W). local quatConjugate = quat:Conjugate()   "},{"title":"Normalize​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Normalize","content":"&lt;/&gt; Quaternion:Normalize() → Quaternion Returns the normalized representation of the Quaternion. local quatNormalized = quat:Normalize()   "},{"title":"Magnitude​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#Magnitude","content":"&lt;/&gt; Quaternion:Magnitude() → number Calculates the magnitude of the Quaternion. local magnitude = quat:Magnitude()   "},{"title":"SqrMagnitude​","type":1,"pageTitle":"Quaternion","url":"/RbxUtil/api/Quaternion#SqrMagnitude","content":"&lt;/&gt; Quaternion:SqrMagnitude() → number Calculates the square magnitude of the Quaternion. local squareMagnitude = quat:Magnitude()  "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/RbxUtil/api/RemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/RbxUtil/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/RbxUtil/api/RemoteSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection "},{"title":"Types","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal##","content":""},{"title":"​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#Connection","content":"interface Connection { Disconnect: () → nil Connected: boolean }  Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/RbxUtil/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"Sequent","type":0,"sectionRef":"#","url":"/RbxUtil/api/Sequent","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#types","content":" "},{"title":"SequentConnection​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#SequentConnection","content":"&lt;/&gt; interface SequentConnection { Connected: boolean Disconnect: (self: SequentConnection) → () } print(sequent.Connected) sequent:Disconnect()   "},{"title":"SequentEvent<T>​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#SequentEvent<T>","content":"&lt;/&gt; interface SequentEvent&lt;T&gt; { Value: T Cancellable: boolean Cancel: (self: SequentEvent&lt;T&gt;) → () } Events are passed to connected callbacks when sequents are fired. Events can be cancelled as well, which prevents the event from propagating to other connected callbacks during the same firing. This can be used to sink events if desired. sequent:Connect(function(event) print(event.Value) event:Cancel() end, 0)   "},{"title":"Priority​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Priority","content":"&lt;/&gt; interface Priority { Highest: math.huge High: 1000 Normal: 0 Low: -1000 Lowest: -math.huge } sequent:Connect(fn, Sequent.Priority.Highest)  "},{"title":"Functions​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#new","content":"&lt;/&gt; Sequent.new(cancellable: boolean?) → Sequent&lt;T&gt; Constructs a new Sequent. If cancellable is true, then connected handlers can cancel event propagation.  "},{"title":"Fire​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Fire","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Sequent:Fire(value: T) → () Fires the Sequent with the given value. This method will yield until all connections complete. Errors will bubble up if they occur within a connection.  "},{"title":"IsFiring​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#IsFiring","content":"&lt;/&gt; Sequent:IsFiring() → boolean Returns true if the Sequent is currently firing.  "},{"title":"Connect​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Connect","content":"&lt;/&gt; Sequent:Connect( callback: (...unknown) → (), priority: number ) → SequentConnection Connects a callback to the Sequent, which gets called anytime Fire is called. The given priority indicates the firing priority of the callback. Higher priority values will be run first. There are a few defaults available via Sequent.Priority.  "},{"title":"Once​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Once","content":"&lt;/&gt; Sequent:Once( callback: (...unknown) → (), priority: number ) → SequentConnection Once() is the same as Connect(), except the connection is automatically disconnected after being fired once.  "},{"title":"Cancel​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Cancel","content":"&lt;/&gt; Sequent:Cancel() → () Cancels a currently-firing Sequent.  "},{"title":"Destroy​","type":1,"pageTitle":"Sequent","url":"/RbxUtil/api/Sequent#Destroy","content":"&lt;/&gt; Sequent:Destroy() → () Cleans up the Sequent. All connections are disconnected. The Sequent is cancelled if it is currently firing. "},{"title":"Ser","type":0,"sectionRef":"#","url":"/RbxUtil/api/Ser","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#properties","content":" "},{"title":"Classes​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#Classes","content":"&lt;/&gt; Ser.Classes: table A dictionary of classes along with a Serialize and Deserialize function. For instance, the default class added is the Option class, which looks like the following: Ser.Classes.Option = { Serialize = function(opt) return opt:Serialize() end; Deserialize = Option.Deserialize; } Add to this table in order to extend what classes are automatically serialized/deserialized. The Ser library checks every object's ClassName field in both serialized and deserialized data in order to map it to the correct function within the Classes table. "},{"title":"Functions​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#functions","content":" "},{"title":"SerializeArgs​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#SerializeArgs","content":"&lt;/&gt; Ser.SerializeArgs(...: any) → args: table Serializes the arguments and returns the serialized values in a table.  "},{"title":"SerializeArgsAndUnpack​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#SerializeArgsAndUnpack","content":"&lt;/&gt; Ser.SerializeArgsAndUnpack(...: any) → args: ...any Serializes the arguments and returns the serialized values.  "},{"title":"DeserializeArgs​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#DeserializeArgs","content":"&lt;/&gt; Ser.DeserializeArgs(...: any) → args: table Deserializes the arguments and returns the deserialized values in a table.  "},{"title":"DeserializeArgsAndUnpack​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#DeserializeArgsAndUnpack","content":"&lt;/&gt; Ser.DeserializeArgsAndUnpack(...: any) → args: table Deserializes the arguments and returns the deserialized values.  "},{"title":"Serialize​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#Serialize","content":"&lt;/&gt; Ser.Serialize(value: any) → any Serializes the given value.  "},{"title":"Deserialize​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#Deserialize","content":"&lt;/&gt; Ser.Deserialize(value: any) → any Deserializes the given value.  "},{"title":"UnpackArgs​","type":1,"pageTitle":"Ser","url":"/RbxUtil/api/Ser#UnpackArgs","content":"&lt;/&gt; Ser.UnpackArgs(value: any) → any Unpacks the arguments returned by either SerializeArgs or DeserializeArgs. "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"/RbxUtil/api/ServerComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/RbxUtil/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object. "},{"title":"Shake","type":0,"sectionRef":"#","url":"/RbxUtil/api/Shake","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#types","content":" "},{"title":"UpdateCallbackFn​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#UpdateCallbackFn","content":"&lt;/&gt; type UpdateCallbackFn = () → ( position: Vector3 , rotation: Vector3 , completed: boolean )  "},{"title":"Properties​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#properties","content":" "},{"title":"Amplitude​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Amplitude","content":"&lt;/&gt; Shake.Amplitude: number Amplitude of the overall shake. For instance, an amplitude of 3 would mean the peak magnitude for the outputted shake vectors would be about 3. Defaults to 1.  "},{"title":"Frequency​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Frequency","content":"&lt;/&gt; Shake.Frequency: number Frequency of the overall shake. This changes how slow or fast the shake occurs. Defaults to 1.  "},{"title":"FadeInTime​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#FadeInTime","content":"&lt;/&gt; Shake.FadeInTime: number How long it takes for the shake to fade in, measured in seconds. Defaults to 1.  "},{"title":"FadeOutTime​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#FadeOutTime","content":"&lt;/&gt; Shake.FadeOutTime: number How long it takes for the shake to fade out, measured in seconds. Defaults to 1.  "},{"title":"SustainTime​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#SustainTime","content":"&lt;/&gt; Shake.SustainTime: number How long it takes for the shake sustains itself after fading in and before fading out. To sustain a shake indefinitely, set Sustain to true, and call the StopSustain() method to stop the sustain and fade out the shake effect. Defaults to 0.  "},{"title":"Sustain​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Sustain","content":"&lt;/&gt; Shake.Sustain: boolean If true, the shake will sustain itself indefinitely once it fades in. If StopSustain() is called, the sustain will end and the shake will fade out based on the FadeOutTime. Defaults to false.  "},{"title":"PositionInfluence​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#PositionInfluence","content":"&lt;/&gt; Shake.PositionInfluence: Vector3  This is similar to Amplitude but multiplies against each axis of the resultant shake vector, and only affects the position vector. Defaults to Vector3.one.  "},{"title":"RotationInfluence​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#RotationInfluence","content":"&lt;/&gt; Shake.RotationInfluence: Vector3  This is similar to Amplitude but multiplies against each axis of the resultant shake vector, and only affects the rotation vector. Defaults to Vector3.one.  "},{"title":"TimeFunction​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#TimeFunction","content":"&lt;/&gt; Shake.TimeFunction: () → number The function used to get the current time. This defaults totime during runtime, and os.clock otherwise. Usually this will not need to be set, but it can be optionally configured if desired. "},{"title":"Functions​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#new","content":"&lt;/&gt; Shake.new() → Shake Construct a new Shake instance.  "},{"title":"InverseSquare​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#InverseSquare","content":"&lt;/&gt; Shake.InverseSquare( shake: Vector3 , distance: number ) → Vector3  Apply an inverse square intensity multiplier to the given vector based on the distance away from some source. This can be used to simulate shake intensity based on the distance the shake is occurring from some source. For instance, if the shake is caused by an explosion in the game, the shake can be calculated as such: local function Explosion(positionOfExplosion: Vector3) local cam = workspace.CurrentCamera local renderPriority = Enum.RenderPriority.Last.Value local shake = Shake.new() -- Set shake properties here local function ExplosionShake(pos: Vector3, rot: Vector3) local distance = (cam.CFrame.Position - positionOfExplosion).Magnitude pos = Shake.InverseSquare(pos, distance) rot = Shake.InverseSquare(rot, distance) cam.CFrame *= CFrame.new(pos) * CFrame.Angles(rot.X, rot.Y, rot.Z) end shake:BindToRenderStep(&quot;ExplosionShake&quot;, renderPriority, ExplosionShake) end   "},{"title":"NextRenderName​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#NextRenderName","content":"&lt;/&gt; Shake.NextRenderName() → string Returns a unique render name for every call, which can be used with the BindToRenderStep method optionally. shake:BindToRenderStep(Shake.NextRenderName(), ...)   "},{"title":"Start​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Start","content":"&lt;/&gt; Shake:Start() → () Start the shake effect. note This must be called before calling Update. As such, it should also be called once before or after calling OnSignal or BindToRenderStep methods.  "},{"title":"Stop​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Stop","content":"&lt;/&gt; Shake:Stop() → () Stops the shake effect. If using OnSignal or BindToRenderStep, those bound functions will be disconnected/unbound. Stop is automatically called when the shake effect is completed or when the Destroy method is called.  "},{"title":"IsShaking​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#IsShaking","content":"&lt;/&gt; Shake:IsShaking() → boolean Returns true if the shake instance is currently running, otherwise returns false.  "},{"title":"StopSustain​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#StopSustain","content":"&lt;/&gt; Shake:StopSustain() → () Schedules a sustained shake to stop. This works by setting theSustain field to false and letting the shake effect fade out based on the FadeOutTime field.  "},{"title":"Update​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Update","content":"&lt;/&gt; Shake:Update() → ( Vector3 , Vector3 , boolean ) Calculates the current shake vector. This should be continuously called inside a loop, such as RunService.Heartbeat. Alternatively, OnSignal or BindToRenderStep can be used to automatically call this function. Returns a tuple of three values: position: Vector3 - Position shake offset rotation: Vector3 - Rotation shake offset completed: boolean - Flag indicating if the shake is finished local hb hb = RunService.Heartbeat:Connect(function() local offsetPosition, offsetRotation, isDone = shake:Update() if isDone then hb:Disconnect() end -- Use `offsetPosition` and `offsetRotation` here end)   "},{"title":"OnSignal​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#OnSignal","content":"&lt;/&gt; Shake:OnSignal( signal: Signal | RBXScriptSignal , callbackFn: UpdateCallbackFn ) → Connection | RBXScriptConnection  Bind the Update method to a signal. For instance, this can be used to connect to RunService.Heartbeat. All connections are cleaned up when the shake instance is stopped or destroyed. local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean) -- Shake end shake:OnSignal(RunService.Heartbeat, SomeShake)   "},{"title":"BindToRenderStep​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#BindToRenderStep","content":"&lt;/&gt; Shake:BindToRenderStep( name: string,-- Name passed to RunService:BindToRenderStep priority: number,-- Priority passed to RunService:BindToRenderStep callbackFn: UpdateCallbackFn ) → () Bind the Update method to RenderStep. All bond functions are cleaned up when the shake instance is stopped or destroyed. local renderPriority = Enum.RenderPriority.Camera.Value local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean) -- Shake end shake:BindToRenderStep(&quot;SomeShake&quot;, renderPriority, SomeShake)   "},{"title":"Clone​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Clone","content":"&lt;/&gt; Shake:Clone() → Shake Creates a new shake with identical properties as this one. This does not clone over playing state, and thus the cloned instance will be in a stopped state. A use-case for using Clone would be to create a module with a list of shake presets. These presets can be cloned when desired for use. For instance, there might be presets for explosions, recoil, or earthquakes. -------------------------------------- -- Example preset module local ShakePresets = {} local explosion = Shake.new() -- Configure `explosion` shake here ShakePresets.Explosion = explosion return ShakePresets -------------------------------------- -- Use the module: local ShakePresets = require(somewhere.ShakePresets) local explosionShake = ShakePresets.Explosion:Clone()   "},{"title":"Destroy​","type":1,"pageTitle":"Shake","url":"/RbxUtil/api/Shake#Destroy","content":"&lt;/&gt; Shake:Destroy() → () Alias for Stop(). "},{"title":"Streamable","type":0,"sectionRef":"#","url":"/RbxUtil/api/Streamable","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#properties","content":" "},{"title":"Instance​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#Instance","content":"&lt;/&gt; Streamable.Instance: Instance  The current instance represented by the Streamable. If this is being observed, it will always exist. If not currently being observed, this will be nil. "},{"title":"Functions​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#new","content":"&lt;/&gt; Streamable.new( parent: Instance , childName: string ) → Streamable Constructs a Streamable that watches for a direct child of name childName within the parent Instance. Call Observe to observe the existence of the child within the parent.  "},{"title":"primary​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#primary","content":"&lt;/&gt; Streamable.primary(parent: Model ) → Streamable Constructs a streamable that watches for the PrimaryPart of the given parent Model.  "},{"title":"Observe​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#Observe","content":"&lt;/&gt; Streamable:Observe(handler: ( instance: Instance , trove: Trove ) → nil) → Connection Observes the instance. The handler is called anytime the instance comes into existence, and the trove given is cleaned up when the instance goes away. To stop observing, disconnect the returned connection.  "},{"title":"Destroy​","type":1,"pageTitle":"Streamable","url":"/RbxUtil/api/Streamable#Destroy","content":"&lt;/&gt; Streamable:Destroy() → () Destroys the Streamable. Any observers will be disconnected, which also means that troves within observers will be cleaned up. This should be called when a streamable is no longer needed. "},{"title":"Silo","type":0,"sectionRef":"#","url":"/RbxUtil/api/Silo","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#types","content":" "},{"title":"State<S>​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#State<S>","content":"&lt;/&gt; type State&lt;S&gt; = {[string]: any} Represents state.  "},{"title":"Modifier<S>​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#Modifier<S>","content":"&lt;/&gt; type Modifier&lt;S&gt; = ( State&lt;S&gt;, any ) → () A function that modifies state.  "},{"title":"Action<A>​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#Action<A>","content":"&lt;/&gt; interface Action&lt;A&gt; { Name: string Payload: A } Actions are passed to Dispatch. However, typically actions are never constructed by hand. Use a silo's Actions table to generate these actions. "},{"title":"Functions​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#new","content":"&lt;/&gt; Silo.new( defaultState: State&lt;S&gt;, modifiers: {Modifier&lt;S&gt;}? ) → Silo Create a Silo. local statsSilo = Silo.new({ -- Initial state: Kills = 0, Deaths = 0, Points = 0, }, { -- Modifiers are functions that modify the state: SetKills = function(state, kills) state.Kills = kills end, AddPoints = function(state, points) state.Points += points end, }) -- Use Actions to modify the state: statsSilo:Dispatch(statsSilo.Actions.SetKills(10)) -- Use GetState to get the current state: print(&quot;Kills&quot;, statsSilo:GetState().Kills) From the above example, note how the modifier functions were transformed into functions that can be called from Actions with just the single payload (no need to pass state). The SetKills modifier is then used as the SetKills action to be dispatched.  "},{"title":"combine​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#combine","content":"&lt;/&gt; Silo.combine( silos: {Silo}, initialState: State&lt;S&gt;? ) → Silo Constructs a new silo as a combination of other silos.  "},{"title":"GetState​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#GetState","content":"&lt;/&gt; Silo:GetState() → State&lt;S&gt; Get the current state. local state = silo:GetState()   "},{"title":"Dispatch​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#Dispatch","content":"&lt;/&gt; Silo:Dispatch(action: Action&lt;A&gt;) → () Dispatch an action. silo:Dispatch(silo.Actions.DoSomething(&quot;something&quot;))   "},{"title":"Subscribe​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#Subscribe","content":"&lt;/&gt; Silo:Subscribe(subscriber: ( newState: State&lt;S&gt;, oldState: State&lt;S&gt; ) → ()) → () → () Subscribe a function to receive all state updates, including initial state (subscriber is called immediately). Returns an unsubscribe function. Call the function to unsubscribe. local unsubscribe = silo:Subscribe(function(newState, oldState) -- Do something end) -- Later on, if desired, disconnect the subscription by calling unsubscribe: unsubscribe()   "},{"title":"Watch​","type":1,"pageTitle":"Silo","url":"/RbxUtil/api/Silo#Watch","content":"&lt;/&gt; Silo:Watch( selector: (State&lt;S&gt;) → T, onChange: (T) → () ) → () → () Watch a specific value within the state, which is selected by theselector function. The initial value, and any subsequent changes grabbed by the selector, will be passed to the onChange function. Just like Subscribe, a function is returned that can be used to unsubscribe (i.e. stop watching). local function SelectPoints(state) return state.Statistics.Points end local unsubscribe = silo:Watch(SelectPoints, function(points) print(&quot;Points&quot;, points) end)  "},{"title":"StreamableUtil","type":0,"sectionRef":"#","url":"/RbxUtil/api/StreamableUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"StreamableUtil","url":"/RbxUtil/api/StreamableUtil#functions","content":" "},{"title":"Compound​","type":1,"pageTitle":"StreamableUtil","url":"/RbxUtil/api/StreamableUtil#Compound","content":"&lt;/&gt; StreamableUtil.Compound( streamables: {Streamable}, handler: ( {[child: string]: Instance }, trove: Trove ) → nil ) → Trove Creates a compound streamable around all the given streamables. The compound streamable's observer handler will be fired once all the given streamables are in existence, and will be cleaned up when any of the streamables disappear. local s1 = Streamable.new(workspace, &quot;Part1&quot;) local s2 = Streamable.new(workspace, &quot;Part2&quot;) local compoundTrove = StreamableUtil.Compound({S1 = s1, S2 = s2}, function(streamables, trove) local part1 = streamables.S1.Instance local part2 = streamables.S2.Instance trove:Add(function() print(&quot;Cleanup&quot;) end) end)  "},{"title":"Signal","type":0,"sectionRef":"#","url":"/RbxUtil/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/RbxUtil/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "},{"title":"Symbol","type":0,"sectionRef":"#","url":"/RbxUtil/api/Symbol","content":"On this page Symbol Represents a unique object. Symbols are often used as unique keys in tables. This is useful to avoid possible collisions with a key in a table, since the symbol will always be unique and cannot be reconstructed. All Unique Every creation of a symbol is unique, even if the given names are the same. local Symbol = require(packages.Symbol) -- Create a symbol: local symbol = Symbol(&quot;MySymbol&quot;) -- The name is optional: local anotherSymbol = Symbol() -- Comparison: print(symbol == symbol) --&gt; true -- All symbol constructions are unique, regardless of the name: print(Symbol(&quot;Hello&quot;) == Symbol(&quot;Hello&quot;)) --&gt; false -- Commonly used as unique keys in a table: local DATA_KEY = Symbol(&quot;Data&quot;) local t = { -- Can only be accessed using the DATA_KEY symbol: [DATA_KEY] = {} } print(t[DATA_KEY]) --&gt; {} ","keywords":""},{"title":"TaskQueue","type":0,"sectionRef":"#","url":"/RbxUtil/api/TaskQueue","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TaskQueue","url":"/RbxUtil/api/TaskQueue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TaskQueue","url":"/RbxUtil/api/TaskQueue#new","content":"&lt;/&gt; TaskQueue.new(onFlush: ({T}) → ()) → TaskQueue&lt;T&gt; Constructs a new TaskQueue.  "},{"title":"Add​","type":1,"pageTitle":"TaskQueue","url":"/RbxUtil/api/TaskQueue#Add","content":"&lt;/&gt; TaskQueue:Add(object: T) → () Add an object to the queue.  "},{"title":"Clear​","type":1,"pageTitle":"TaskQueue","url":"/RbxUtil/api/TaskQueue#Clear","content":"&lt;/&gt; TaskQueue:Clear() → () Clears the TaskQueue. This will clear any tasks that were scheduled to be flushed on the current execution frame. queue:Add(something1) queue:Add(something2) queue:Clear()   "},{"title":"Destroy​","type":1,"pageTitle":"TaskQueue","url":"/RbxUtil/api/TaskQueue#Destroy","content":"&lt;/&gt; TaskQueue:Destroy() → () Destroys the TaskQueue. Just an alias for Clear(). "},{"title":"Touch","type":0,"sectionRef":"#","url":"/RbxUtil/api/Touch","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#properties","content":" "},{"title":"TouchTap​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchTap","content":"Event &lt;/&gt; Touch.TouchTap: Signal&lt;( touchPositions: {Vector2 }, processed: boolean )&gt; Proxy for UserInputService.TouchTap.  "},{"title":"TouchTapInWorld​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchTapInWorld","content":"Event &lt;/&gt; Touch.TouchTapInWorld: Signal&lt;( position: Vector2 , processed: boolean )&gt; Proxy for UserInputService.TouchTapInWorld.  "},{"title":"TouchMoved​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchMoved","content":"Event &lt;/&gt; Touch.TouchMoved: Signal&lt;( touch: InputObject , processed: boolean )&gt; Proxy for UserInputService.TouchMoved.  "},{"title":"TouchLongPress​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchLongPress","content":"Event &lt;/&gt; Touch.TouchLongPress: Signal&lt;( touchPositions: {Vector2 }, state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchLongPress.  "},{"title":"TouchPan​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchPan","content":"Event &lt;/&gt; Touch.TouchPan: Signal&lt;( touchPositions: {Vector2 }, totalTranslation: Vector2 , velocity: Vector2 , state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPan.  "},{"title":"TouchPinch​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchPinch","content":"Event &lt;/&gt; Touch.TouchPinch: Signal&lt;( touchPositions: {Vector2 }, scale: number, velocity: Vector2 , state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPinch.  "},{"title":"TouchRotate​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchRotate","content":"Event &lt;/&gt; Touch.TouchRotate: Signal&lt;( touchPositions: {Vector2 }, rotation: number, velocity: number, state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchRotate.  "},{"title":"TouchSwipe​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchSwipe","content":"Event &lt;/&gt; Touch.TouchSwipe: Signal&lt;( swipeDirection: Enum.SwipeDirection, numberOfTouches: number, processed: boolean )&gt; Proxy for UserInputService.TouchSwipe.  "},{"title":"TouchStarted​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchStarted","content":"Event &lt;/&gt; Touch.TouchStarted: Signal&lt;( touch: InputObject , processed: boolean )&gt; Proxy for UserInputService.TouchStarted.  "},{"title":"TouchEnded​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#TouchEnded","content":"Event &lt;/&gt; Touch.TouchEnded: Signal&lt;( touch: InputObject , processed: boolean )&gt; Proxy for UserInputService.TouchEnded. "},{"title":"Functions​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#new","content":"&lt;/&gt; Touch.new() → () Constructs a new Touch input capturer.  "},{"title":"IsTouchEnabled​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#IsTouchEnabled","content":"&lt;/&gt; Touch:IsTouchEnabled() → boolean Returns the value of UserInputService.TouchEnabled.  "},{"title":"Destroy​","type":1,"pageTitle":"Touch","url":"/RbxUtil/api/Touch#Destroy","content":"&lt;/&gt; Touch:Destroy() → () Destroys the Touch input capturer. "},{"title":"Tree","type":0,"sectionRef":"#","url":"/RbxUtil/api/Tree","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Tree","url":"/RbxUtil/api/Tree#functions","content":" "},{"title":"Find​","type":1,"pageTitle":"Tree","url":"/RbxUtil/api/Tree#Find","content":"&lt;/&gt; Tree.Find( parent: Instance , path: string, assertIsA: string? ) → Instance  Similar to FindFirstChild, with a few key differences: An error is thrown if the instance is not found A path to the instance can be provided, delimited by forward slashes (e.g. Path/To/Child) Optionally, the instance's type can be asserted using IsA -- Find &quot;Child&quot; directly under parent: local instance = Tree.Find(parent, &quot;Child&quot;) -- Find &quot;Child&quot; descendant: local instance = Tree.Find(parent, &quot;Path/To/Child&quot;) -- Find &quot;Child&quot; descendant and assert that it's a BasePart: local instance = Tree.Find(parent, &quot;Path/To/Child&quot;, &quot;BasePart&quot;) :: BasePart   "},{"title":"Exists​","type":1,"pageTitle":"Tree","url":"/RbxUtil/api/Tree#Exists","content":"&lt;/&gt; Tree.Exists( parent: Instance , path: string, assertIsA: string? ) → boolean Returns true if the instance is found. Similar to Tree.Find, except this returns true|false. No error is thrown unless the path is invalid. -- Check if &quot;Child&quot; exists directly in `parent`: if Tree.Exists(parent, &quot;Child&quot;) then ... end -- Check if &quot;Child&quot; descendant exists at `parent.Path.To.Child`: if Tree.Exists(parent, &quot;Path/To/Child&quot;) then ... end -- Check if &quot;Child&quot; descendant exists at `parent.Path.To.Child` and is a BasePart: if Tree.Exists(parent, &quot;Path/To/Child&quot;, &quot;BasePart&quot;) then ... end   "},{"title":"Await​","type":1,"pageTitle":"Tree","url":"/RbxUtil/api/Tree#Await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Tree.Await( parent: Instance , path: string, timeout: number?, assertIsA: string? ) → Instance  Waits for the path to exist within the parent instance. Similar to Tree.Find, except WaitForChild is used internally. An optional timeout can be supplied, which is passed along to each call to WaitForChild. An error is thrown if the path fails to resolve. This will only happen if the path is invalid or if the supplied timeout is reached. Indefinite Yield Possible If the timeout parameter is not supplied, then the internal call to WaitForChild will yield indefinitely until the child is found. It is good practice to supply a timeout parameter. local child = Tree.Await(parent, &quot;Path/To/Child&quot;, 30)  "},{"title":"Timer","type":0,"sectionRef":"#","url":"/RbxUtil/api/Timer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#types","content":" "},{"title":"CallbackFn​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#CallbackFn","content":"&lt;/&gt; type CallbackFn = () → () Callback function.  "},{"title":"TimeFn​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#TimeFn","content":"&lt;/&gt; type TimeFn = () → number Time function. "},{"title":"Properties​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#properties","content":" "},{"title":"Interval​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Interval","content":"&lt;/&gt; Timer.Interval: number Interval at which the Tick event fires.  "},{"title":"UpdateSignal​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#UpdateSignal","content":"&lt;/&gt; Timer.UpdateSignal: RBXScriptSignal | Signal The signal which updates the timer internally.  "},{"title":"TimeFunction​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#TimeFunction","content":"&lt;/&gt; Timer.TimeFunction: TimeFn The function which gets the current time.  "},{"title":"AllowDrift​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#AllowDrift","content":"&lt;/&gt; Timer.AllowDrift: boolean Flag which indicates if the timer is allowed to drift. This is set to true by default. This flag must be set before calling Start or StartNow. This flag should only be set to false if it is necessary for drift to be eliminated.  "},{"title":"Tick​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Tick","content":"&lt;/&gt; Timer.Tick: RBXScriptSignal | Signal The event which is fired every time the timer hits its interval. "},{"title":"Functions​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#new","content":"&lt;/&gt; Timer.new(interval: number) → Timer Creates a new timer.  "},{"title":"Simple​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Simple","content":"&lt;/&gt; Timer.Simple( interval: number, callback: CallbackFn, startNow: boolean?, updateSignal: RBXScriptSignal? , timeFn: TimeFn? ) → RBXScriptConnection  Creates a simplified timer which just fires off a callback function at the given interval. -- Basic: Timer.Simple(1, function() print(&quot;Tick&quot;) end) -- Using other arguments: Timer.Simple(1, function() print(&quot;Tick&quot;) end, true, RunService.Heartbeat, os.clock)   "},{"title":"Is​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Is","content":"&lt;/&gt; Timer.Is(obj: any) → boolean Returns true if the given object is a Timer.  "},{"title":"Start​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Start","content":"&lt;/&gt; Timer:Start() → () Starts the timer. Will do nothing if the timer is already running. timer:Start()   "},{"title":"StartNow​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#StartNow","content":"&lt;/&gt; Timer:StartNow() → () Starts the timer and fires off the Tick event immediately. Will do nothing if the timer is already running. timer:StartNow()   "},{"title":"Stop​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Stop","content":"&lt;/&gt; Timer:Stop() → () Stops the timer. Will do nothing if the timer is already stopped. timer:Stop()   "},{"title":"IsRunning​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#IsRunning","content":"&lt;/&gt; Timer:IsRunning() → boolean Returns true if the timer is currently running. if timer:IsRunning() then -- Do something end   "},{"title":"Destroy​","type":1,"pageTitle":"Timer","url":"/RbxUtil/api/Timer#Destroy","content":"&lt;/&gt; Timer:Destroy() → () Destroys the timer. This will also stop the timer. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/RbxUtil/docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxUtil/docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory, and then add the various utility modules found here as dependencies. For example, the following could be a wally.toml file for a project that includes a few of these modules: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] Signal = &quot;sleitnick/signal@^1&quot; TableUtil = &quot;sleitnick/table-util@^1&quot;  To install these dependencies, run wally install within your project. Wally will create a Package folder in your directory with the installed dependencies. "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"/RbxUtil/docs/intro#rojo-configuration","content":"The Package folder created by Wally should be synced into Roblox Studio through your Rojo configuration. For instance, a Rojo configuration might have the following entry to sync the Packages folder into ReplicatedStorage: { &quot;name&quot;: &quot;rbx-util-example&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } } }  "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"/RbxUtil/docs/intro#usage-example","content":"The installed dependencies can now be used in scripts, such as the following: -- Reference folder with packages: local Packages = game:GetService(&quot;ReplicatedStorage&quot;).Packages -- Require the utility modules: local Signal = require(Packages.Signal) local TableUtil = require(Packages.TableUtil) -- Use the modules: local signal = Signal.new() signal:Connect(function(data) local randomizedData = TableUtil.Shuffle(data) print(randomizedData) end) signal:Fire({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;})  "},{"title":"WaitFor","type":0,"sectionRef":"#","url":"/RbxUtil/api/WaitFor","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#properties","content":" "},{"title":"Error​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Error","content":"&lt;/&gt; WaitFor.Error: { Unparented: string, ParentChanged: string }  "},{"title":"Functions​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#functions","content":" "},{"title":"Child​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Child","content":"&lt;/&gt; WaitFor.Child( parent: Instance , childName: string, timeout: number? ) → Promise&lt;Instance &gt; Wait for a child to exist within a given parent based on the child name. WaitFor.Child(parent, &quot;SomeObject&quot;):andThen(function(someObject) print(someObject, &quot;now exists&quot;) end):catch(warn)   "},{"title":"Children​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Children","content":"&lt;/&gt; WaitFor.Children( parent: Instance , childrenNames: {string}, timeout: number? ) → Promise&lt;{Instance }&gt; Wait for all children to exist within the given parent. WaitFor.Children(parent, {&quot;SomeObject01&quot;, &quot;SomeObject02&quot;}):andThen(function(children) local someObject01, someObject02 = table.unpack(children) end) note Once all children are found, a second check is made to ensure that all children are still directly parented to the given parent (since one child's parent might have changed before another child was found). A rejected promise with the WaitFor.Error.ParentChanged error will be thrown if any parents of the children no longer match the given parent.  "},{"title":"Descendant​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Descendant","content":"&lt;/&gt; WaitFor.Descendant( parent: Instance , descendantName: string, timeout: number? ) → Promise&lt;Instance &gt; Wait for a descendant to exist within a given parent. This is similar toWaitFor.Child, except it looks for all descendants instead of immediate children. WaitFor.Descendant(parent, &quot;SomeDescendant&quot;):andThen(function(someDescendant) print(&quot;SomeDescendant now exists&quot;) end)   "},{"title":"Descendants​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Descendants","content":"&lt;/&gt; WaitFor.Descendants( parent: Instance , descendantNames: {string}, timeout: number? ) → Promise&lt;{Instance }&gt; Wait for all descendants to exist within a given parent. WaitFor.Descendants(parent, {&quot;SomeDescendant01&quot;, &quot;SomeDescendant02&quot;}):andThen(function(descendants) local someDescendant01, someDescendant02 = table.unpack(descendants) end) note Once all descendants are found, a second check is made to ensure that none of the instances have moved outside of the parent (since one instance might change before another instance is found). A rejected promise with the WaitFor.Error.ParentChanged error will be thrown if any of the instances are no longer descendants of the given parent.  "},{"title":"PrimaryPart​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#PrimaryPart","content":"&lt;/&gt; WaitFor.PrimaryPart( model: Model , timeout: number? ) → Promise&lt;Instance &gt; Wait for the PrimaryPart of a model to exist. WaitFor.PrimaryPart(model):andThen(function(primaryPart) print(primaryPart == model.PrimaryPart) end)   "},{"title":"ObjectValue​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#ObjectValue","content":"&lt;/&gt; WaitFor.ObjectValue( objectValue: ObjectValue , timeout: number? ) → Promise&lt;Instance &gt; Wait for the Value of an ObjectValue to exist. WaitFor.ObjectValue(someObjectValue):andThen(function(value) print(&quot;someObjectValue's value is&quot;, value) end)   "},{"title":"Custom​","type":1,"pageTitle":"WaitFor","url":"/RbxUtil/api/WaitFor#Custom","content":"&lt;/&gt; WaitFor.Custom( predicate: () → T?, timeout: number? ) → Promise&lt;T&gt; Wait for the given predicate function to return a non-nil value of of type T. The predicate is fired every RunService Heartbeat step. -- Example, waiting for some property to be set: WaitFor.Custom(function() return vectorForce.Attachment0 end):andThen(function(a0) print(a0) end)  "},{"title":"TableUtil","type":0,"sectionRef":"#","url":"/RbxUtil/api/TableUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#functions","content":" "},{"title":"Copy​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Copy","content":"&lt;/&gt; TableUtil.Copy( tbl: table,-- Table to copy deep: boolean?-- Whether or not to perform a deep copy ) → table Creates a copy of the given table. By default, a shallow copy is performed. For deep copies, a second boolean argument must be passed to the function. No cyclical references Deep copies are not protected against cyclical references. Passing a table with cyclical references and the deep parameter set to true will result in a stack-overflow.  "},{"title":"Sync​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Sync","content":"&lt;/&gt; TableUtil.Sync( srcTbl: table,-- Source table templateTbl: table-- Template table ) → table Synchronizes the srcTbl based on the templateTbl. This will make sure that srcTbl has all of the same keys as templateTbl, including removing keys in srcTbl that are not present in templateTbl. This is a deep operation, so any nested tables will be synchronized as well. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, experience = 12} data = TableUtil.Sync(data, template) print(data) --&gt; {kills = 10, deaths = 0, xp = 0} Data Loss Warning This is a two-way sync, so the source table will have dataremoved that isn't found in the template table. This can be problematic if used for player data, where there might be dynamic data added that isn't in the template. For player data, use TableUtil.Reconcile instead.  "},{"title":"Reconcile​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Reconcile","content":"&lt;/&gt; TableUtil.Reconcile( source: table, template: table ) → table Performs a one-way sync on the source table against the template table. Any keys found in template that are not found in source will be added to source. This is useful for syncing player data against data template tables to ensure players have all the necessary keys, while maintaining existing keys that may no longer be in the template. This is a deep operation, so nested tables will also be properly reconciled. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, abc = 20} local correctedData = TableUtil.Reconcile(data, template) print(correctedData) --&gt; {kills = 10, deaths = 0, xp = 0, abc = 20}   "},{"title":"SwapRemove​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#SwapRemove","content":"&lt;/&gt; TableUtil.SwapRemove( tbl: table,-- Array i: number-- Index ) → () Removes index i in the table by swapping the value at i with the last value in the array, and then trimming off the last value from the array. This allows removal of the value at i in O(1) time, but does not preserve array ordering. If a value needs to be removed from an array, but ordering of the array does not matter, using SwapRemove is always preferred over table.remove. In the following example, we remove &quot;B&quot; at index 2. SwapRemove does this by moving the last value &quot;E&quot; over top of &quot;B&quot;, and then trimming off &quot;E&quot; at the end of the array: local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemove(t, 2) -- Remove &quot;B&quot; print(t) --&gt; {&quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"SwapRemoveFirstValue​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#SwapRemoveFirstValue","content":"&lt;/&gt; TableUtil.SwapRemoveFirstValue( tbl: table,-- Array v: any-- Value to find ) → number? Performs table.find(tbl, v) to find the index of the given value, and then performs TableUtil.SwapRemove on that index. local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemoveFirstValue(t, &quot;C&quot;) print(t) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Map​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Map","content":"&lt;/&gt; TableUtil.Map( tbl: table, predicate: ( value: any, key: any, tbl: table ) → newValue: any ) → table Performs a map operation against the given table, which can be used to map new values based on the old values at given keys/indices. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Map(t, function(value) return value * 2 end) print(t2) --&gt; {A = 20, B = 40, C = 60}   "},{"title":"Filter​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Filter","content":"&lt;/&gt; TableUtil.Filter( tbl: table, predicate: ( value: any, key: any, tbl: table ) → keep: boolean ) → table Performs a filter operation against the given table, which can be used to filter out unwanted values from the table. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Filter(t, function(value, key) return value &gt; 15 end) print(t2) --&gt; {B = 40, C = 60}   "},{"title":"Reduce​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Reduce","content":"&lt;/&gt; TableUtil.Reduce( tbl: table, predicate: ( accumulator: any, value: any, index: any, tbl: table ) → result: any ) → table Performs a reduce operation against the given table, which can be used to reduce the table into a single value. This could be used to sum up a table or transform all the values into a compound value of any kind. For example: local t = {10, 20, 30, 40} local result = TableUtil.Reduce(t, function(accum, value) return accum + value end) print(result) --&gt; 100   "},{"title":"Assign​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Assign","content":"&lt;/&gt; TableUtil.Assign( target: table, ...: table ) → table Copies all values of the given tables into the target table. local t = {A = 10} local t2 = {B = 20} local t3 = {C = 30, D = 40} local newT = TableUtil.Assign(t, t2, t3) print(newT) --&gt; {A = 10, B = 20, C = 30, D = 40}   "},{"title":"Extend​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Extend","content":"&lt;/&gt; TableUtil.Extend( target: table, extension: table ) → table Extends the target array with the extension array. local t = {10, 20, 30} local t2 = {30, 40, 50} local tNew = TableUtil.Extend(t, t2) print(tNew) --&gt; {10, 20, 30, 30, 40, 50} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Reverse​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Reverse","content":"&lt;/&gt; TableUtil.Reverse(tbl: table) → table Reverses the array. local t = {1, 5, 10} local tReverse = TableUtil.Reverse(t) print(tReverse) --&gt; {10, 5, 1} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Shuffle​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Shuffle","content":"&lt;/&gt; TableUtil.Shuffle( tbl: table, rngOverride: Random? ) → table Shuffles the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local shuffled = TableUtil.Shuffle(t) print(shuffled) --&gt; e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sample​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Sample","content":"&lt;/&gt; TableUtil.Sample( tbl: table, sampleSize: number, rngOverride: Random? ) → table Returns a random sample of the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local sample = TableUtil.Sample(t, 3) print(sample) --&gt; e.g. {6, 2, 5} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Flat​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Flat","content":"&lt;/&gt; TableUtil.Flat( tbl: table, depth: number? ) → table Returns a new table where all sub-arrays have been bubbled up to the top. The depth at which the scan is performed is dictated by the depth parameter, which is set to 1 by default. local t = {{10, 20}, {90, 100}, {30, 15}} local flat = TableUtil.Flat(t) print(flat) --&gt; {10, 20, 90, 100, 30, 15} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"FlatMap​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#FlatMap","content":"&lt;/&gt; TableUtil.FlatMap( tbl: table, predicate: ( key: any, value: any, tbl: table ) → newValue: any ) → table Calls TableUtil.Map on the given table and predicate, and then calls TableUtil.Flat on the result from the map operation. local t = {10, 20, 30} local result = TableUtil.FlatMap(t, function(value) return {value, value * 2} end) print(result) --&gt; {10, 20, 20, 40, 30, 60} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Keys​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Keys","content":"&lt;/&gt; TableUtil.Keys(tbl: table) → table Returns an array with all the keys in the table. local t = {A = 10, B = 20, C = 30} local keys = TableUtil.Keys(t) print(keys) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} Ordering The ordering of the keys is never guaranteed. If order is imperative, calltable.sort on the resulting keys array. local keys = TableUtil.Keys(t) table.sort(keys)   "},{"title":"Values​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Values","content":"&lt;/&gt; TableUtil.Values(tbl: table) → table Returns an array with all the values in the table. local t = {A = 10, B = 20, C = 30} local values = TableUtil.Values(t) print(values) --&gt; {10, 20, 30} Ordering The ordering of the values is never guaranteed. If order is imperative, calltable.sort on the resulting values array. local values = TableUtil.Values(t) table.sort(values)   "},{"title":"Find​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Find","content":"&lt;/&gt; TableUtil.Find( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → ( value: any?, key: any? ) Performs a linear scan across the table and calls callback on each item in the array. Returns the value and key of the first pair in which the callback returns true. local t = { {Name = &quot;Bob&quot;, Age = 20}; {Name = &quot;Jill&quot;, Age = 30}; {Name = &quot;Ann&quot;, Age = 25}; } -- Find first person who has a name starting with J: local firstPersonWithJ = TableUtil.Find(t, function(person) return person.Name:sub(1, 1):lower() == &quot;j&quot; end) print(firstPersonWithJ) --&gt; {Name = &quot;Jill&quot;, Age = 30} Dictionary Ordering While Find can also be used with dictionaries, dictionary ordering is never guaranteed, and thus the result could be different if there are more than one possible matches given the data and callback function.  "},{"title":"Every​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Every","content":"&lt;/&gt; TableUtil.Every( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for every item in the table. local t = {10, 20, 40, 50, 60} local allAboveZero = TableUtil.Every(t, function(value) return value &gt; 0 end) print(&quot;All above zero:&quot;, allAboveZero) --&gt; All above zero: true   "},{"title":"Some​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Some","content":"&lt;/&gt; TableUtil.Some( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for at least one of the items in the table. local t = {10, 20, 40, 50, 60} local someBelowTwenty = TableUtil.Some(t, function(value) return value &lt; 20 end) print(&quot;Some below twenty:&quot;, someBelowTwenty) --&gt; Some below twenty: true   "},{"title":"Truncate​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Truncate","content":"&lt;/&gt; TableUtil.Truncate( tbl: table, length: number ) → table Returns a new table truncated to the length of length. Any length equal or greater than the current length will simply return a shallow copy of the table. local t = {10, 20, 30, 40, 50, 60, 70, 80} local tTruncated = TableUtil.Truncate(t, 3) print(tTruncated) --&gt; {10, 20, 30}   "},{"title":"Zip​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Zip","content":"&lt;/&gt; TableUtil.Zip(...: table) → ( iter: ( t: table, k: any ) → ( key: any?, values: table? ), tbl: table, startIndex: any? ) Returns an iterator that can scan through multiple tables at the same time side-by-side, matching against shared keys/indices. local t1 = {10, 20, 30, 40, 50} local t2 = {60, 70, 80, 90, 100} for key,values in TableUtil.Zip(t1, t2) do print(key, values) end --[[ Outputs: 1 {10, 60} 2 {20, 70} 3 {30, 80} 4 {40, 90} 5 {50, 100} --]]   "},{"title":"Lock​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#Lock","content":"&lt;/&gt; TableUtil.Lock(tbl: table) → table Locks the table using table.freeze, as well as any nested tables within the given table. This will lock the whole deep structure of the table, disallowing any further modifications. local tbl = {xyz = {abc = 32}} tbl.xyz.abc = 28 -- Works fine TableUtil.Lock(tbl) tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)   "},{"title":"IsEmpty​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#IsEmpty","content":"&lt;/&gt; TableUtil.IsEmpty(tbl: table) → boolean Returns true if the given table is empty. This is simply performed by checking if next(tbl) is nil and works for both arrays and dictionaries. This is useful when needing to check if a table is empty but not knowing if it is an array or dictionary. TableUtil.IsEmpty({}) -- true TableUtil.IsEmpty({&quot;abc&quot;}) -- false TableUtil.IsEmpty({abc = 32}) -- false   "},{"title":"EncodeJSON​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#EncodeJSON","content":"&lt;/&gt; TableUtil.EncodeJSON(value: any) → string Proxy for HttpService:JSONEncode.  "},{"title":"DecodeJSON​","type":1,"pageTitle":"TableUtil","url":"/RbxUtil/api/TableUtil#DecodeJSON","content":"&lt;/&gt; TableUtil.DecodeJSON(value: any) → string Proxy for HttpService:JSONDecode. "},{"title":"Trove","type":0,"sectionRef":"#","url":"/RbxUtil/api/Trove","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#new","content":"&lt;/&gt; Trove.new() → Trove Constructs a Trove object.  "},{"title":"Extend​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Extend","content":"&lt;/&gt; Trove:Extend() → Trove Creates and adds another trove to itself. This is just shorthand for trove:Construct(Trove). This is useful for contexts where the trove object is present, but the class itself isn't. note This does not clone the trove. In other words, the objects in the trove are not given to the new constructed trove. This is simply to construct a new Trove and add it as an object to track. local trove = Trove.new() local subTrove = trove:Extend() trove:Clean() -- Cleans up the subTrove too   "},{"title":"Clone​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Clone","content":"&lt;/&gt; Trove:Clone(instance: Instance ) → Instance  Clones the given instance and adds it to the trove. Shorthand fortrove:Add(instance:Clone()).  "},{"title":"Construct​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Construct","content":"&lt;/&gt; Trove:Construct( class: table | (...any) → any, ...: any ) → any Constructs a new object from either the table or function given. If a table is given, the table's new function will be called with the given arguments. If a function is given, the function will be called with the given arguments. The result from either of the two options will be added to the trove. This is shorthand for trove:Add(SomeClass.new(...)) and trove:Add(SomeFunction(...)). local Signal = require(somewhere.Signal) -- All of these are identical: local s = trove:Construct(Signal) local s = trove:Construct(Signal.new) local s = trove:Construct(function() return Signal.new() end) local s = trove:Add(Signal.new()) -- Even Roblox instances can be created: local part = trove:Construct(Instance, &quot;Part&quot;)   "},{"title":"Connect​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Connect","content":"&lt;/&gt; Trove:Connect( signal: RBXScriptSignal , fn: (...: any) → () ) → RBXScriptConnection  Connects the function to the signal, adds the connection to the trove, and then returns the connection. This is shorthand for trove:Add(signal:Connect(fn)). trove:Connect(workspace.ChildAdded, function(instance) print(instance.Name .. &quot; added to workspace&quot;) end)   "},{"title":"BindToRenderStep​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#BindToRenderStep","content":"&lt;/&gt; Trove:BindToRenderStep( name: string, priority: number, fn: (dt: number) → () ) → () Calls RunService:BindToRenderStep and registers a function in the trove that will call RunService:UnbindFromRenderStep on cleanup. trove:BindToRenderStep(&quot;Test&quot;, Enum.RenderPriority.Last.Value, function(dt) -- Do something end)   "},{"title":"AddPromise​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#AddPromise","content":"&lt;/&gt; Trove:AddPromise(promise: Promise) → Promise Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise is removed. The exact promise is returned, thus allowing chaining. trove:AddPromise(doSomethingThatReturnsAPromise()) :andThen(function() print(&quot;Done&quot;) end) -- Will cancel the above promise (assuming it didn't resolve immediately) trove:Clean() local p = trove:AddPromise(doSomethingThatReturnsAPromise()) -- Will also cancel the promise trove:Remove(p) Promise v4 Only This is only compatible with the roblox-lua-promise library, version 4.  "},{"title":"Add​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Add","content":"&lt;/&gt; Trove:Add( object: any,-- Object to track cleanupMethod: string?-- Optional cleanup name override ) → object: any Adds an object to the trove. Once the trove is cleaned or destroyed, the object will also be cleaned up. The following types are accepted (e.g. typeof(object)): Type Cleanup Instance object:Destroy() RBXScriptConnection object:Disconnect() function object() thread task.cancel(object) table object:Destroy() or object:Disconnect() table with cleanupMethod object:&lt;cleanupMethod&gt;() Returns the object added. -- Add a part to the trove, then destroy the trove, -- which will also destroy the part: local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Destroy() -- Add a function to the trove: trove:Add(function() print(&quot;Cleanup!&quot;) end) trove:Destroy() -- Standard cleanup from table: local tbl = {} function tbl:Destroy() print(&quot;Cleanup&quot;) end trove:Add(tbl) -- Custom cleanup from table: local tbl = {} function tbl:DoSomething() print(&quot;Do something on cleanup&quot;) end trove:Add(tbl, &quot;DoSomething&quot;)   "},{"title":"Remove​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Remove","content":"&lt;/&gt; Trove:Remove( object: any-- Object to remove ) → boolean Removes the object from the Trove and cleans it up. local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Remove(part)   "},{"title":"Clean​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Clean","content":"&lt;/&gt; Trove:Clean() → () Cleans up all objects in the trove. This is similar to calling Remove on each object within the trove. The ordering of the objects removed is not guaranteed.  "},{"title":"AttachToInstance​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#AttachToInstance","content":"&lt;/&gt; Trove:AttachToInstance(instance: Instance ) → RBXScriptConnection  Attaches the trove to a Roblox instance. Once this instance is removed from the game (parent or ancestor's parent set to nil), the trove will automatically clean up. caution Will throw an error if instance is not a descendant of the game hierarchy.  "},{"title":"Destroy​","type":1,"pageTitle":"Trove","url":"/RbxUtil/api/Trove#Destroy","content":"&lt;/&gt; Trove:Destroy() → () Alias for trove:Clean(). "},{"title":"TypeScript","type":0,"sectionRef":"#","url":"/RbxUtil/docs/ts","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#installation","content":"Installing modules works like any other roblox-ts package, except that the prefix will be @rbxutil. For instance, to install the quaternion library, run the following command: $ npm install @rbxutil/quaternion  "},{"title":"Configuration​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#configuration","content":"In order for modules from @rbxutil to work, two changes will need to be made: Add the modules to the Rojo project fileExpose the types to TypeScript "},{"title":"Rojo Project​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#rojo-project","content":"In the default.project.json file, add the @rbxutil directory into ReplicatedStorage, right alongside @rbxts: &quot;node_modules&quot;: { &quot;$className&quot;: &quot;Folder&quot;, &quot;@rbxts&quot;: { &quot;$path&quot;: &quot;node_modules/@rbxts&quot; }, &quot;@rbxutil&quot;: { &quot;$path&quot;: &quot;node_modules/@rbxutil&quot; } }  "},{"title":"Types Configuration​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#types-configuration","content":"In the tsconfig.json file, add the @rbxutil directory to the types list. The @rbxts org should already be there: &quot;typeRoots&quot;: [&quot;node_modules/@rbxts&quot;, &quot;node_modules/@rbxutil&quot;]  "},{"title":"Different Org​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#different-org","content":"In order to avoid naming conflicts and namespace cluttering, RbxUtil modules will be placed in their own NPM org (@rbxutil). This has been done out of respect for roblox-ts package developers and to allow RbxUtil to grow unbounded by the current default org packages. For example, there is already a Signal package within the default @rbxts org. Also, RbxUtil has many generic names, such as Log and Shake. While these are named to convey their meaning easily, it is best to not clutter the @rbxts org with a vast array of such names from a single repository. This naming issue is not an issue for Wally, as Wally uses the author's name as the namespace. "},{"title":"Contributing​","type":1,"pageTitle":"TypeScript","url":"/RbxUtil/docs/ts#contributing","content":"If you find any types that are incorrect, missing, or broken, please feel free to open up a GitHub Issue and/or pull request to address and fix these issues. "}]