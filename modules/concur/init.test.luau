local ServerScriptService = game:GetService("ServerScriptService")

local Test = require(ServerScriptService.TestRunner.Test)

return function(ctx: Test.TestContext)
	local Concur = require(script.Parent)

	local function Awaiter(timeout: number)
		local awaiter = {}
		local thread
		local delayThread
		function awaiter.Resume(...)
			if coroutine.running() ~= delayThread then
				task.cancel(delayThread)
			end
			task.spawn(thread, ...)
		end
		function awaiter.Yield()
			thread = coroutine.running()
			delayThread = task.delay(timeout, function()
				awaiter.Resume()
			end)
			return coroutine.yield()
		end
		return awaiter
	end

	local bindableEvent
	ctx:BeforeEach(function()
		bindableEvent = Instance.new("BindableEvent")
	end)
	ctx:AfterEach(function()
		bindableEvent:Destroy()
		bindableEvent = nil
	end)

	ctx:Describe("Single", function()
		ctx:Test("should spawn a new concur instance", function()
			local value = nil
			ctx:Expect(function()
				Concur.spawn(function()
					value = 10
				end)
			end)
				:Not()
				:ToThrow()
			ctx:Expect(value):ToBe(10)
		end)

		ctx:Test("should defer a new concur instance", function()
			local awaiter = Awaiter(1)
			ctx:Expect(function()
				Concur.defer(function()
					awaiter.Resume(10)
				end)
			end)
				:Not()
				:ToThrow()
			local value = awaiter.Yield()
			ctx:Expect(value):ToBe(10)
		end)

		ctx:Test("should delay a new concur instance", function()
			local awaiter = Awaiter(1)
			ctx:Expect(function()
				Concur.delay(0.1, function()
					awaiter.Resume(10)
				end)
			end)
				:Not()
				:ToThrow()
			local value = awaiter.Yield()
			ctx:Expect(value):ToBe(10)
		end)

		ctx:Test("should create an immediate value concur instance", function()
			local c
			ctx:Expect(function()
				c = Concur.value(10)
			end)
				:Not()
				:ToThrow()
			ctx:Expect(c):ToBeOk()
			ctx:Expect(c:IsCompleted()):ToBe(true)
			local err, val = c:Await()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should create a concur instance to watch an event with no predicate", function()
			local c
			ctx:Expect(function()
				c = Concur.event(bindableEvent.Event)
			end)
				:Not()
				:ToThrow()
			ctx:Expect(c:IsCompleted()):ToBe(false)
			bindableEvent:Fire(10)
			local err, val = c:Await(1)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should create a concur instance to watch an event with a predicate", function()
			local c
			ctx:Expect(function()
				c = Concur.event(bindableEvent.Event, function(v)
					return v < 10
				end)
			end)
				:Not()
				:ToThrow()
			ctx:Expect(c:IsCompleted()):ToBe(false)
			bindableEvent:Fire(10)
			bindableEvent:Fire(5)
			local err, val = c:Await(1)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(5)
		end)
	end)

	ctx:Describe("Multi", function()
		ctx:Test("should complete all concur instances", function()
			local c1 = Concur.spawn(function()
				return 10
			end)
			local c2 = Concur.defer(function()
				return 20
			end)
			local c3 = Concur.delay(0, function()
				return 30
			end)
			local c4 = Concur.spawn(function()
				error("fail")
			end)
			local c5 = Concur.event(bindableEvent.Event)
			local c = Concur.all({ c1, c2, c3, c4, c5 })
			ctx:Expect(c:IsCompleted()):ToBe(false)
			bindableEvent:Fire(40)
			local err, res = c:Await(1)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(res[1][1]):ToBeNil()
			ctx:Expect(res[1][2]):ToBe(10)
			ctx:Expect(res[2][1]):ToBeNil()
			ctx:Expect(res[2][2]):ToBe(20)
			ctx:Expect(res[3][1]):ToBeNil()
			ctx:Expect(res[3][2]):ToBe(30)
			ctx:Expect(res[4][1]):ToBeOk()
			ctx:Expect(res[4][2]):ToBeNil()
			ctx:Expect(res[5][1]):ToBeNil()
			ctx:Expect(res[5][2]):ToBe(40)
		end)

		ctx:Test("should complete the first concur instance", function()
			local c1 = Concur.defer(function()
				return 10
			end)
			local c2 = Concur.spawn(function()
				return 20
			end)
			local c = Concur.first({ c1, c2 })
			local err, res = c:Await(1)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(res):ToBe(20)
		end)
	end)

	ctx:Describe("Stop", function()
		ctx:Test("should stop a single concur", function()
			local c1 = Concur.defer(function()
				return 10
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(false)
			c1:Stop()
			ctx:Expect(c1:IsCompleted()):ToBe(true)
			local err, val = c1:Await()
			ctx:Expect(err):ToBe(Concur.Errors.Stopped)
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should stop multiple concurs", function()
			local c1 = Concur.defer(function() end)
			local c2 = Concur.delay(1, function() end)
			local c3 = Concur.event(bindableEvent.Event)
			local c = Concur.all({ c1, c2, c3 })
			c:Stop()
			local err, val = c:Await()
			ctx:Expect(err):ToBe(Concur.Errors.Stopped)
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should not stop an already completed concur", function()
			local c1 = Concur.spawn(function()
				return 10
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(true)
			c1:Stop()
			local err, val = c1:Await()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)
	end)

	ctx:Describe("IsCompleted", function()
		ctx:Test("should correctly check if a concur instance is completed", function()
			local c1 = Concur.defer(function() end)
			ctx:Expect(c1:IsCompleted()):ToBe(false)
			local err = c1:Await()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(c1:IsCompleted()):ToBe(true)
		end)

		ctx:Test("should be marked as completed if error", function()
			local c1 = Concur.spawn(function()
				error("err")
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(true)
		end)

		ctx:Test("should be marked as completed if stopped", function()
			local c1 = Concur.defer(function() end)
			c1:Stop()
			ctx:Expect(c1:IsCompleted()):ToBe(true)
		end)
	end)

	ctx:Describe("Await", function()
		ctx:Test("should await concur to be completed", function()
			local c1 = Concur.defer(function()
				return 10
			end)
			local err, val = c1:Await(1)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should await concur to be completed even if error", function()
			local c1 = Concur.defer(function()
				return error("err")
			end)
			local err, val = c1:Await(1)
			ctx:Expect(err):ToBeOk()
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should await concur to be completed even if stopped", function()
			local c1 = Concur.delay(0.1, function()
				return 10
			end)
			task.defer(function()
				c1:Stop()
			end)
			local err, val = c1:Await(1)
			ctx:Expect(err):ToBe(Concur.Errors.Stopped)
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should return completed values immediately if already completed", function()
			local c1 = Concur.spawn(function()
				return 10
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(true)
			local err, val = c1:Await()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should timeout", function()
			local c1 = Concur.delay(0.2, function()
				return 10
			end)
			local err, val = c1:Await(0.1)
			ctx:Expect(err):ToBe(Concur.Errors.Timeout)
			ctx:Expect(val):ToBeNil()
			err, val = c1:Await()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)
	end)

	ctx:Describe("OnCompleted", function()
		ctx:Test("should fire function once completed", function()
			local awaiter = Awaiter(0.1)
			local c1 = Concur.defer(function()
				return 10
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(false)
			c1:OnCompleted(function(err, val)
				awaiter.Resume(err, val)
			end)
			local err, val = awaiter.Yield()
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should fire function even if already completed", function()
			local c1 = Concur.spawn(function()
				return 10
			end)
			ctx:Expect(c1:IsCompleted()):ToBe(true)
			local err, val
			c1:OnCompleted(function(e, v)
				err, val = e, v
			end)
			ctx:Expect(err):ToBeNil()
			ctx:Expect(val):ToBe(10)
		end)

		ctx:Test("should fire function even if error", function()
			local awaiter = Awaiter(0.1)
			local c1 = Concur.defer(function()
				error("err")
			end)
			c1:OnCompleted(function(err, val)
				awaiter.Resume(err, val)
			end)
			local err, val = awaiter.Yield()
			ctx:Expect(err):ToBeOk()
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should fire function even if stopped", function()
			local awaiter = Awaiter(0.2)
			local c1 = Concur.delay(0.1, function()
				error("err")
			end)
			c1:OnCompleted(function(err, val)
				awaiter.Resume(err, val)
			end)
			task.defer(function()
				c1:Stop()
			end)
			local err, val = awaiter.Yield()
			ctx:Expect(err):ToBe(Concur.Errors.Stopped)
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should fire function even if timeout", function()
			local awaiter = Awaiter(0.5)
			local c1 = Concur.delay(0.2, function()
				error("err")
			end)
			c1:OnCompleted(function(err, val)
				awaiter.Resume(err, val)
			end, 0.1)
			local err, val = awaiter.Yield()
			ctx:Expect(err):ToBe(Concur.Errors.Timeout)
			ctx:Expect(val):ToBeNil()
		end)

		ctx:Test("should unbind function", function()
			local c1 = Concur.defer(function() end)
			local val = nil
			local unbind = c1:OnCompleted(function()
				val = 10
			end)
			unbind()
			local err = c1:Await()
			ctx:Expect(err):ToBeNil()
			task.wait()
			ctx:Expect(val):ToBeNil()
		end)
	end)
end
